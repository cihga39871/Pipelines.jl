var documenterSearchIndex = {"docs":
[{"location":"command_dependency/#Command-Dependency","page":"Command Dependency","title":"Command Dependency","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"Command Dependency (CmdDependency) is the external dependent program that can be used in Command Program (CmdProgram).","category":"page"},{"location":"command_dependency/#Create","page":"Command Dependency","title":"Create","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"CmdDependency(;\n    exec::Base.AbstractCmd=``,\n    test_args::Base.AbstractCmd=``,\n    validate_success::Bool=false,\n    validate_stdout::Function=do_nothing,\n    validate_stderr::Function=do_nothing,\n    exit_when_fail::Bool=true\n)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"exec::AbstractCmd: the command to call the dependency.\ntest_args::AbstractCmd: for testing purposes, the command to be appended to exec.\nvalidate_success::Bool: when checking the dependency, whether to validate the exit code == 0.\nvalidate_stdout::Function: a function takes standard out as String and return the validation result as ::Bool.\nvalidate_stderr::Function: a function takes standard error as String and return the validation result as ::Bool.\nexit_when_fail::Bool: if validation fails, whether to throw error and exit.","category":"page"},{"location":"command_dependency/#Example","page":"Command Dependency","title":"Example","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"julia = CmdDependency(\n    exec = `julia`,\n    test_args = `--version`,\n    validate_success = true,\n    validate_stdout = x -> occursin(r\"^julia version\", x),\n    validate_stderr = do_nothing,\n    exit_when_fail = true\n)","category":"page"},{"location":"command_dependency/#Check","page":"Command Dependency","title":"Check","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"CmdDependency can be checked manually by using","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"check_dependency(p::CmdDependency)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"Usually, it is not necessary when you specify CmdDependency in CmdProgram because dependency check will be done when running CmdProgram by default.","category":"page"},{"location":"command_dependency/#Use-with-CmdProgram","page":"Command Dependency","title":"Use with CmdProgram","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"When building CmdProgram, we can specify our command dependencies by using","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"dep1 = CmdDependency(...)\ndep2 = CmdDependency(...)\n\nprog = CmdProgram(\n    cmd_dependencies = [dep1, dep2],\n    ...\n)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"To call the dependency in command, we can prepend a dollor sign ($):","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"prog = CmdProgram(\n    cmd_dependencies = [dep1, dep2],\n    cmd = `$dep1 --args` & `$dep2 --args`\n)","category":"page"},{"location":"command_dependency/#An-Example","page":"Command Dependency","title":"An Example","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"We use the same example in Command Program page.","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"Adding samtools and bowtie2 as the dependencies of the bowtie2 mapping program:","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"SAMTOOLS = CmdDependency(\n    exec = `samtools`,\n    test_args = `--version`,\n    validate_success = true,\n    validate_stdout = x -> occursin(r\"^samtools \\d+\", x)\n)\n\nBOWTIE2 = CmdDependency(\n    exec = `bowtie2`,\n    test_args = `--version`,\n    validate_success = true,\n    validate_stdout = x -> occursin(r\"bowtie2-align-s version \\d+\", x)\n)\n\nprogram_bowtie2 = CmdProgram(\n    name = \"Bowtie2 Mapping\",\n    id_file = \".bowtie2\",\n\n    cmd_dependencies = [SAMTOOLS, BOWTIE2],\n\n    inputs = [\"FASTQ\", \"REF\"],\n    validate_inputs = inputs -> begin\n        check_dependency_file(inputs[\"FASTQ\"]) &&\n        check_dependency_file(inputs[\"REF\"])\n    end,\n\n    prerequisites = (inputs, outputs) -> begin\n        mkpath(dirname(to_str(outputs[\"BAM\"])))\n    end,\n\n    outputs = [\"BAM\"],\n    infer_outputs = inputs -> begin\n        Dict(\"BAM\" => str(inputs[\"FASTQ\"]) * \".bam\")\n    end,\n    validate_outputs = outputs -> begin\n        check_dependency_file(outputs[\"BAM\"])\n    end,\n\n    cmd = pipeline(`$BOWTIE2 -x REF -q FASTQ`, `$SAMTOOLS sort -O bam -o BAM`),\n\n    wrap_up = (inputs, outputs) -> run(`$SAMTOOLS index $(outputs[\"BAM\"])`)\n)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"To run the program, we can decide whether to check dependencies with run(..., check_dependencies=true):","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"inputs = Dict(\"FASTQ\" => \"a.fastq\", \"REF\" => \"ref.fasta\")\nsuccess, outputs = run(program_bowtie2, inputs; check_dependencies = true)","category":"page"},{"location":"tips_and_troubleshoots/#Tips-and-Troubleshoots","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"This page summarizes tips and troubleshoots when building workflow using Pipelines.jl","category":"page"},{"location":"tips_and_troubleshoots/#Named-tuple-for-common-arguments","page":"Tips & Troubleshoots","title":"Named tuple for common arguments","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"A workflow usually has many Programs, and all Programs have some common run arguments. We can use a named tuple to store and use the common arguments easily.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"using Pipelines\n\nprog_A = CmdProgram(...)\nprog_B = JuliaProgram(...)\n\ncommon_run_args = (check_dependencies = false, skip_when_done = true, touch_run_id_file = true, verbose = :min, retry = 1)\n\nrun(prog_A; prog_A_args..., common_run_args...)\nrun(prog_B; prog_B_args..., common_run_args...)","category":"page"},{"location":"tips_and_troubleshoots/#Run-different-programs-in-parallel","page":"Tips & Troubleshoots","title":"Run different programs in parallel","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"When building a computational workflow, we may find different programs use different CPU and memory. Some can run simultaneously, but some have to run sequentially. To efficiently use computational resources, we highly recommend to use JobSchedulers.jl. It is stable, useful and powerful package for task queuing and workload management, and are fully compatible with Pipelines.jl","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"run(prog; prog_args..., run_args...) can be replaced by the JobScheduler way:","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"job = Job(prog; prog_args..., run_args..., job_args...)\nsubmit!(job)","category":"page"},{"location":"tips_and_troubleshoots/#An-example","page":"Tips & Troubleshoots","title":"An example","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"A workflow comprises the following steps:","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"Run prog_A with 2 threads and 4GB RAM.\nRun prog_B with 8 threads.\nAfter prog_A finished, run prog_C (2 threads).\nAfter prog_B and prog_C finished, run prog_D (12 threads)","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"using JobSchedulers, Pipelines\n\nscheduler_start() # start the job scheduler\n\nprog_A = CmdProgram(...)\nprog_B = JuliaProgram(...)\nprog_C = CmdProgram(...)\nprog_D = JuliaProgram(...)\n\njob_A = Job(prog_A, A_args..., ncpu = 2, mem = 4GB)\nsubmit!(job_A)\n\njob_B = Job(prog_B, B_args..., ncpu = 8)\nsubmit!(job_B)\n\njob_C = Job(prog_C, C_args..., ncpu = 2, dependency = DONE => job_A)\nsubmit!(job_C)\n\njob_D = Job(prog_D, D_args..., ncpu = 12, dependency = [DONE => job_B, DONE => job_C])\nsubmit!(job_D)","category":"page"},{"location":"tips_and_troubleshoots/#Argument-forward","page":"Tips & Troubleshoots","title":"Argument forward","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"Usually a parallel program has an input argument of # cpu, and Job() has a ncpu argument. Because ncpu is reserved (Pipelines.RESERVED_KEY_SET) and cannot be used as Program inputs, it is awkward to write code in this way:","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"prog = CmdProgram(inputs = [:NCPU => 1], ...)  # default num CPU is 1\njob = Job(prog, NCPU = 8, ncpu = 8)            # use 8 CPUs in the job","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"To make life easier, we can define arg_forward in Program to forward the input :NCPU to Job argument ncpu:","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"prog = CmdProgram(inputs = [:NCPU => 1], arg_forward = :NCPU => :ncpu, ...)\njob = Job(prog, NCPU = 8)\n# Job:\n#   ...\n#   ncpu → 8\n#   ...","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"note: arg_forward in Program\narg_forward: forward args from inputs and outputs to specific keywords in JobSchedulers.Job(), only supporting Pipelines.FORWARD_KEY_SET: [:ncpu, :mem, :user, :name]. Elements (or vectors containing elements) in the following format: \"arg_of_inputs_or_outputs\" => :key_in_FORWARD_KEY_SET.","category":"page"},{"location":"tips_and_troubleshoots/#Name-of-inputs-and-outputs:-String-or-Symbol?","page":"Tips & Troubleshoots","title":"Name of inputs and outputs: String or Symbol?","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"Normally the name should be a String: CmdProgram(inputs = [\"IN\"], outputs = [\"OUT\"]). However, if an argument does not affect results (such as number of threads), it is called an independent argument, and has to be a Symbol. Symbol arguments are ignored when generating unique run IDs to prevent re-running a program. Arguments of inputs and outputs will be converted to Arg objects.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"See also: Arg","category":"page"},{"location":"tips_and_troubleshoots/#UndefVarError-in-quote-...-end","page":"Tips & Troubleshoots","title":"UndefVarError in quote ... end","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"quote creates a piece of code without using the explicit Expr constructor. It creates an Expr object and follows the scoping rules of Julia Expression.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"An Exprression will be evaluated in the global scope of the Module defined in Program(..., mod = Module), and then converted to a function using Pipelines.quote_function.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"Thus, directly using local variables (including functions) in Expr will lead to UndefVarError. To use a local variable, you need to follow the rules:","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"A local variable (include function) should be referenced using $ in expression.\nA local ::Symbol variable (sym) should be referenced using $(QuoteNode(sym)) in expression.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"Example:","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"inputs = [\"A\", \"B\"]\ng_var = 3\ng_sym = :globalsymbol\n\nfunction gen_expr()\n    l_var = 5\n    l_func() = @info(\"Use local function\")\n    l_sym = :abc\n    expr = quote\n        @show inputs\n        @show g_var\n        @show g_sym\n        @show $(QuoteNode(l_sym))\n        @show $l_var + 2\n        $l_func()\n        A + B\n    end\nend\n\nexpr = gen_expr()\nfunc = Pipelines.quote_function(expr, inputs; mod = @__MODULE__)\n\nin_dict = Dict(\"A\" => 5, \"B\" => 50) # func takes Dict{String} as argument\nfunc(in_dict)","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"See also: quote_expr","category":"page"},{"location":"tips_and_troubleshoots/#Fail-to-Precompile-a-module-containing-a-Program","page":"Tips & Troubleshoots","title":"Fail to Precompile a module containing a Program","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"It is because you pass quote ... end to a Program, but forget to add mod = @__MODULE__ to it.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"Fix is simple:","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"prog = CmdProgram(...)                    # fail precompilation\nprog = CmdProgram(..., mod = @__MODULE__) # pass precompilation","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"See also: quote_expr","category":"page"},{"location":"tips_and_troubleshoots/#I-changed-Program-inputs,-but-Program-skipped-and-outputs-not-updated","page":"Tips & Troubleshoots","title":"I changed Program inputs, but Program skipped and outputs not updated","text":"","category":"section"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"The Program probably does not read or write files, and you may adjust inputs and outputs back and forth.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"If we have a pure Program without reading and writing files, we cannot guarantee the state of the arguments.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"A work-around is to intentionally create a file with a fixed name, and the file name is defined in Program's outputs.","category":"page"},{"location":"tips_and_troubleshoots/","page":"Tips & Troubleshoots","title":"Tips & Troubleshoots","text":"See Pipelines.create_run_id_file to learn how Pipelines.jl decides whether a program needs re-run, and its limitation.","category":"page"},{"location":"julia_program/#Julia-Program","page":"Julia Program","title":"Julia Program","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"Please read the Command Program section in Manual page first.","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"Pipelines are built with multiple Programs. Program is the abstract type contains CmdProgram and JuliaProgram.","category":"page"},{"location":"julia_program/#Differences-between-CmdProgram-and-JuliaProgram","page":"Julia Program","title":"Differences between CmdProgram and JuliaProgram","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"JuliaProgram and CmdProgram are generally the same and remain most compatibility, except for the differences:","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"Diff cp :: CmdProgram jp :: JuliaProgram\nUnique Field cp has a command template: cp.cmd::AbstractCmd jp has a main Julia code: jp.main that can be defined using quote .. end .\nMethod to Run Replace keywords in cp.cmd with values in user defined inputs and outputs} If main is a Expr, the variables mentioned in inputs and outputs will be replaced to the inputs[\"VAR\"] format, and then a Julia function returning outputs::Dict{String} is created and called. If main isa Function, it just invokes jp.main(inputs::Dict{String}, outputs::Dict).\nReturned Outputs outputs provided in run(...) does not change outputs will only be overwritten by the returned value of jp.main when the returned value is a Dict and passes p.validate_outputs.\nDry Run Return (replaced_cmd::AbstractCmd, run_id_file::String) Return (fake_outputs::Dict{String}, run_id_file::String)","category":"page"},{"location":"julia_program/#Structure","page":"Julia Program","title":"Structure","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"JuliaProgram can be built with this method:","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"JuliaProgram <: Program\n\nJuliaProgram(;\n    name::String                            = \"Julia Program\",\n    id_file::String                         = \"\",\n    info_before::String                     = \"auto\",\n    info_after::String                      = \"auto\",\n    cmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n    inputs                                  = Vector{String}(),\n    validate_inputs::Expr                   = do_nothing,  # vars of inputs\n    infer_outputs::Expr                     = do_nothing,  # vars of inputs\n    prerequisites::Expr                     = do_nothing,  # vars of inputs and outputs\n    main::Expr                              = do_nothing,  # vars of inputs and outputs\n    outputs                                 = Vector{String}(),\n    validate_outputs::Expr                  = do_nothing,  # vars of outputs\n    wrap_up::Expr                           = do_nothing   # vars of inputs and outputs\n) -> JuliaProgram","category":"page"},{"location":"julia_program/#Run","page":"Julia Program","title":"Run","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"To run a JuliaProgram, the methods are the same as CmdProgram:","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"success, outputs = run(\n    p::Program;\n    program_kwargs...,\n    dir::AbstractString=\"\",\n    check_dependencies::Bool=true,\n    skip_when_done::Bool=true,\n    touch_run_id_file::Bool=true,\n    verbose=true,\n    retry::Int=0,\n    dry_run::Bool=false,\n    stdout=nothing,\n    stderr=nothing,\n    stdlog=nothing,\n    append::Bool=false\n) -> (success::Bool, outputs::Dict{String})","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"program_kwargs... include elements in p.inputs and p.outputs\nOther keyword arguments are related to run. Details can be found at run.","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"warning: Thread safety\nRedirecting and directory change in Julia are not thread safe, so unexpected redirection and directory change might be happen if you are running programs in different Tasks or multi-thread mode.","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"compat: Compatibility with JobSchedulers.jl\nPipelines.jl is fully compatible with JobSchedulers.jl which is a Julia-based job scheduler and workload manager inspired by Slurm and PBS.run(::Program, ...) can be replaced by Job(::Program, ...). The latter creates a Job, and you can submit the job to queue by using submit!(::Job). See example below.","category":"page"},{"location":"julia_program/#Example","page":"Julia Program","title":"Example","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"using Pipelines\n\np = JuliaProgram(\n    id_file = \"id_file\",\n    inputs = [\"a\",\n              \"b\" => Int],\n    outputs = \"c\" => \"<a>.<b>\",\n    main = quote\n        println(\"inputs are \", a, \" and \", b)\n        println(\"You can also use info in outputs: \", outputs[\"c\"])\n        println(\"The returned value will be assigned to a new outputs\")\n        println(\"It is ok to use inputs and outputs directly:\")\n        @show inputs\n        @show outputs\n        c = b^2\n    end)\n\n# running the program using `run`: keyword arguments include keys of inputs and outputs\nsuccess, new_out = run(p; a = `in1`, b = 2, c = \"out\", touch_run_id_file = false)\n\n# an old way to `run` program: need to create inputs and outputs first.\ninputs = Dict(\"a\" => `in1`, \"b\" => 2)\noutputs = \"c\" => \"out\"\nsuccess, new_out = run(p, inputs, outputs; touch_run_id_file = false)\n\n# for CmdProgram, outputs are inferred before running the main command, however,\n# for JuliaProgram, outputs will change to the returned value of main function, if the returned value is a Dict and pass `p.validate_outputs`\n@assert new_out != outputs","category":"page"},{"location":"julia_program/#Compatibility-with-JobSchedulers.jl","page":"Julia Program","title":"Compatibility with JobSchedulers.jl","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"using JobSchedulers\n\nscheduler_start()  # start job scheduler\n\njob = Job(p, a=`in1`, b=2, out=\"any\", touch_run_id_file=false)\n\nsubmit!(job)  # submit job to queue\n\nresult(job)  # get the returned result\n","category":"page"},{"location":"command_program/#Command-Program","page":"Command Program","title":"Command Program","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Please read the Quick Start section in Home page first.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Pipelines are built with multiple Programs. Program is the abstract type contains CmdProgram and JuliaProgram.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"A CmdProgram contains a command template, lists of dependencies/inputs/outputs, and predefined methods to prepare run-time environment, validate dependencies/inputs/outputs, and so on.","category":"page"},{"location":"command_program/#An-Example","page":"Command Program","title":"An Example","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We will go through an example to illustrate how to write a CmdProgram.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"The example is a robust Bowtie2 mapping program. It shows every feature of CmdProgram, but in reality, we do not need that much validation.","category":"page"},{"location":"command_program/#Define-the-Name","page":"Command Program","title":"Define the Name","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    name = \"Bowtie2 Mapping\",# The name of CmdProgram\n    id_file = \".bowtie2\"     # When job completed, a file \".bowtie2.xxxxxx\" will\n                             # be created to indicate the job is finished to\n                             # avoid re-run.\n)","category":"page"},{"location":"command_program/#Main-Command-(Required)","page":"Command Program","title":"Main Command (Required)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"In Bash script, the main code of the example:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"REF=/path/to/reference_genome\nFASTQ=/path/to/input_fastq_file\nBAM=/path/to/output_bam_file\nNTHREADS=8\n\nbowtie2 --threads $NTHREADS -x $REF -q $FASTQ | samtools sort -O bam -o $BAM","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"The equivalent version using CmdProgram:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    inputs = [\n        \"FASTQ\" => String,\n        \"REF\" => \"human_genome_hg38.fa\" => String,\n        :NTHREADS => Int => 8\n    ],\n    outputs = \"BAM\" => String,\n    cmd = pipeline(`bowtie2 --threads NTHREADS -x REF -q FASTQ`, `samtools sort -O bam -o BAM`)\n)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Now, the code can be run by invoking run(program_bowtie2; FASTQ = \"x\", REF = \"y\", NTHREADS = 8, BAM = \"z\"), but to illustrate all features, we will add more things to make it robust and easy to use.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"tip: Name of arguments: String or Symbol\nNormally the name should be a String. However, if the argument does not affect results (such as number of threads), it needs to be a Symbol. Symbol arguments are ignored when generating unique run IDs to prevent re-running a program. Arguments will be converted to Arg objects.","category":"page"},{"location":"command_program/#Command-Dependency-(Robustness)","page":"Command Program","title":"Command Dependency (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We use samtools and bowtie2 (two bioinformatics programs) as command dependencies. They can be wrapped in CmdDependency.","category":"page"},{"location":"command_program/#Infer-Outputs-(Convenience)","page":"Command Program","title":"Infer Outputs (Convenience↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We can set a default method to generate outputs::Dict{String} from inputs, which allows us run the program without specifying outputs. Elements in inputs can be directly used as variables.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    outputs = \"BAM\" => String,\n    infer_outputs = quote\n        Dict(\"BAM\" => FASTQ * \".bam\")\n    end,\n    ...\n)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"tip: Quote usage in Program\nQuote is a piece of code of the type Expression. See details in quote_expr.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Or, the following does the same job:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    outputs = \"BAM\" => \"<FASTQ>.bam\" => String,\n    ...\n)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"tip: Useful functions to change file names\nreplaceext: replace file extension.\nremoveext: remove file extension.\nto_str: converts most types to String.\nto_cmd: converts most types to Cmd.More details are in the API/Utils page.","category":"page"},{"location":"command_program/#Validate-Inputs-(Robustness)","page":"Command Program","title":"Validate Inputs (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"To make the code robust, we can check whether the inputs exists by using validate_inputs. Elements in inputs can be directly used as variables.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    inputs = [\n        \"FASTQ\" => String,\n        \"REF\" => \"human_genome_hg38.fa\" => String\n    ],\n    validate_inputs = quote\n        check_dependency_file(FASTQ) && check_dependency_file(REF)\n    end,\n    ...\n)","category":"page"},{"location":"command_program/#Prerequisites-(Robustness)","page":"Command Program","title":"Prerequisites (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We also need to prepare something (prerequisites) before running the main command. For example, create the output directory if not exist. Elements in inputs and outputs can be directly used as variables.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    prerequisites = quote\n        mkpath(dirname(BAM))\n    end\n)","category":"page"},{"location":"command_program/#Validate-Outputs-(Robustness)","page":"Command Program","title":"Validate Outputs (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"After running the main command, we can validate outputs by using validate_outputs. Elements in outputs can be directly used as variables.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    outputs = \"BAM\",\n    validate_outputs = quote\n        check_dependency_file(BAM)\n    end,\n    ...\n)","category":"page"},{"location":"command_program/#Wrap-Up-(Convenience)","page":"Command Program","title":"Wrap Up (Convenience↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"After validating outputs, we may also do something to wrap up, such as removing temporary files. Here, we build an index for output BAM file. Elements in inputs and outputs can be directly used as variables.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    wrap_up = quote\n        run(`samtools index $BAM`)  # dollar sign is necessary in quote, unlike Pipelines(;cmd = ...) cannot use dollar sign.\n    end\n)","category":"page"},{"location":"command_program/#The-Final-Code","page":"Command Program","title":"The Final Code","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"All in all, the final program is like this:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    name = \"Bowtie2 Mapping\",\n    id_file = \".bowtie2\",\n\n    inputs = [\n        \"FASTQ\" => String,\n        \"REF\" => \"human_genome_hg38.fa\" => String\n    ],\n\n    outputs = [\"BAM\" => String],\n    infer_outputs = quote\n        Dict(\"BAM\" => FASTQ * \".bam\")\n    end,\n\n    validate_inputs = quote\n        check_dependency_file(FASTQ) && check_dependency_file(REF)\n    end,\n\n    prerequisites = quote\n        mkpath(dirname(BAM))\n    end,\n\n    validate_outputs = quote\n        check_dependency_file(BAM)\n    end,\n\n    cmd = pipeline(`bowtie2 -x REF -q FASTQ`, `samtools sort -O bam -o BAM`),  # do not use dollar sign here.\n\n    wrap_up = quote\n        run(`samtools index $BAM`)  # unlike cmd = ..., dollar sign is necessary in all quotes!\n    end\n)","category":"page"},{"location":"command_program/#Structure","page":"Command Program","title":"Structure","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"CmdProgram can be built with this method:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"CmdProgram <: Program\n\nCmdProgram(;\n    name::String                            = \"Command Program\",\n    id_file::String                         = \"\",\n    info_before::String                     = \"auto\",\n    info_after::String                      = \"auto\",\n    cmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n    inputs                                  = Vector{String}(),\n    validate_inputs::Expr                   = do_nothing,  # vars of inputs\n    infer_outputs::Expr                     = do_nothing,  # vars of inputs\n    prerequisites::Expr                     = do_nothing,  # vars of inputs and outputs\n    cmd::Base.AbstractCmd                   = ``,\n    outputs                                 = Vector{String}(),\n    validate_outputs::Expr                  = do_nothing,  # vars of outputs\n    wrap_up::Expr                           = do_nothing,   # vars of inputs and outputs\n    arg_forward                             = Vector{Pair{String,Symbol}}(),\n    mod::Module                             = Pipelines    # please change to @__MODULE__\n\n) -> CmdProgram","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"In this way, all preparation and post-evaluation can be wrapped in a single CmdProgram. It is easy to maintain and use.","category":"page"},{"location":"command_program/#Run","page":"Command Program","title":"Run","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"To run a Program, use this method:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"success, outputs = run(\n    p::Program;\n    program_kwargs...,\n    dir::AbstractString=\"\",\n    check_dependencies::Bool=true,\n    skip_when_done::Bool=true,\n    touch_run_id_file::Bool=true,\n    verbose=true,\n    retry::Int=0,\n    dry_run::Bool=false,\n    stdout=nothing,\n    stderr=nothing,\n    stdlog=nothing,\n    append::Bool=false\n) -> (success::Bool, outputs::Dict{String})","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_kwargs... include elements in p.inputs and p.outputs\nOther keyword arguments are related to run. Details can be found at run.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"compat: Compat\nThe old methods < v0.8 still work, which put program's arguments in inputs::Dict{String} and outputs::Dict{String}:success, outputs = run(p::Program, inputs, outputs; run_kwargs...)\n# only usable when outputs have default values.\nsuccess, outputs = run(p::Program, inputs; run_kwargs...)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"warning: Argument mod::Module\nExprressions will be evaluated to functions in mod. Please use mod = @__MODULE__ to prevent precompilation fail when defining the program within a package.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"warning: Warning\nRedirecting and directory change in Julia are not thread safe, so unexpected redirection and directory change might be happen if you are running programs in different Tasks or multi-thread mode.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"compat: Compatibility with JobSchedulers.jl\nPipelines.jl is fully compatible with JobSchedulers.jl which is a Julia-based job scheduler and workload manager inspired by Slurm and PBS.run(::Program, ...) can be replaced by JobSchedulers.Job(::Program, ...). The latter creates a Job, and you can submit the job to queue by using submit!(::Job).arg_forward (an argument of CmdProgram) is used to forward user-defined inputs/outputs to specific keyword arguments of JobSchedulers.Job(::Program, ...), including name::String, user::String, ncpu::Int, mem::Int.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"The explanation of arguments is in the next section.","category":"page"},{"location":"command_program/#Workflow","page":"Command Program","title":"Workflow","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Go to the working directory. Establish redirection. (dir, stdout, stderr, stdlog, append).\nCheck keywords consistency: Inputs/outputs keywords should be consistent in both p::CmdProgram and run(p; inputs..., outputs...).\nFor example, if inputs and outputs in p::CmdProgram is defined this wayp = CmdProgram(..., inputs = [\"I\", \"J\"], outputs = [\"K\"])You have to provide all I, J and K:run(p; I = something, J = something, K = something)\nPrint info about starting program.\nThe content can set by p.info_before::String.Disable: run(..., verbose=false)\nCheck whether the program ran successfully before. If so, return (true, outputs::Dict{String}) without running it.\nHow does the program know it ran before?a. run(..., skip_when_done=true) skip running the program if it has been done before.b. Run id file stores files information. File will be compared to determine re-run or not. You can use run(..., touch_run_id_file=false) to skip creating the run id file. Details of run id file can be found at Pipelines.create_run_id_filec. p.validate_outputs(outputs) run successfully without returning false.\nCheck command dependencies (CmdDependency).\nDisable: run(..., check_dependencies=false)Read Command Dependency portion for details.\nRemove the run id file if exists.\nValidate inputs. (p.validate_inputs)\nPreparing the main command.\nIf you specify run(...; stdout=something, stderr=something, append::Bool), the command (cmd) will be wrapped with pipeline(cmd; stdout=something, stderr=something, append::Bool). If cmd has its own file redirection, the outer wrapper may not work as you expect.\nMeet prerequisites. (p.prerequisites)\nIt is the last code before running the main command.  For example, you can create a directory if  the main command cannot create itself.\nRun the main command.\nValidate outputs. (p.validate_outputs)\nRun the wrap up code. (p.wrap_up)\nIt is the last code to do after-command jobs. For example, you can delete intermediate files if necessary.\nCreate run id file if run(..., touch_run_id_file=true). Read Step 4 for details.\nPrint info about finishing program.\nThe content can set by p.info_after::String.Disable: run(..., verbose=false)Simple info: run(..., verbose=min)\nReturn (success::Bool, outputs{String})","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"note: Dry Run\nrun(..., dry_run=true) will return (mature_command::AbstractCmd, run_id_file::String) instead.","category":"page"},{"location":"changelog/#Change-Log","page":"Change Log","title":"Change Log","text":"","category":"section"},{"location":"changelog/#v0.10.6","page":"Change Log","title":"v0.10.6","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: run(::Program): wrap pwd() in try-catch block in case the dir no longer exists. It happens because workding dir is not thread safe in Julia. If other program delete the directory, it will fail. ","category":"page"},{"location":"changelog/#v0.10.5","page":"Change Log","title":"v0.10.5","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Julia v1.10: hasmethod(f, t) in Julia v1.10 changed its behavior. It affects Program function check. Use length(methods(f, t)) instead.","category":"page"},{"location":"changelog/#v0.10.4","page":"Change Log","title":"v0.10.4","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Julia v1.9: init(): change the if statement of printing Base.stdxxx was changed when initiating Pipelines.jl: now detects WindowsRawSocket.","category":"page"},{"location":"changelog/#v0.10.3","page":"Change Log","title":"v0.10.3","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Julia v1.9: init(): change the if statement of printing Base.stdxxx was changed when initiating Pipelines.jl: now detects RawFD.","category":"page"},{"location":"changelog/#v0.10.2","page":"Change Log","title":"v0.10.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Julia v1.9: init(): change the if statement of printing Base.stdxxx was changed when initiating Pipelines.jl: now detects <fd>\nChange using FilePathsBase to import FilePathsBase:AbstractPath to avoid variable conflict.","category":"page"},{"location":"changelog/#v0.10.1","page":"Change Log","title":"v0.10.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: the flaw of recursion of keyword_interpolation.","category":"page"},{"location":"changelog/#v0.10.0","page":"Change Log","title":"v0.10.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: remove reexport of FilePathsBase package to suppress warning 'Both Dates and FilePathsBase exports canonicalize'.","category":"page"},{"location":"changelog/#v0.9.10","page":"Change Log","title":"v0.9.10","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: run: wrap cd(dir_backup) in try-catch block in case the dir no longer exists. happens because workding dir is not thread safe in Julia. If other program delete the directory, it will fail.","category":"page"},{"location":"changelog/#v0.9.9","page":"Change Log","title":"v0.9.9","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: redirection.jl: wrap all redirect_stdXXX in the try-catch block.","category":"page"},{"location":"changelog/#v0.9.8","page":"Change Log","title":"v0.9.8","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: flush ios after task finished (redirect_to_files).","category":"page"},{"location":"changelog/#v0.9.6-v0.9.7","page":"Change Log","title":"v0.9.6 - v0.9.7","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: not showing warning when Base.stdout or Base.stderr is system file redirection (IOStream, fd) when initiating Pipelines.jl","category":"page"},{"location":"changelog/#v0.9.5","page":"Change Log","title":"v0.9.5","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Docs: add new page: tips and trobleshoots.","category":"page"},{"location":"changelog/#v0.9.4","page":"Change Log","title":"v0.9.4","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Docs: better documentation on run id file: Pipelines.create_run_id_file.\nFeature: Pipelines.CMD_FILE_SPLITER.","category":"page"},{"location":"changelog/#v0.9.3","page":"Change Log","title":"v0.9.3","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: run id file also try to record all possible files from Base.AbstractCmd inputs/outputs.","category":"page"},{"location":"changelog/#v0.9.2","page":"Change Log","title":"v0.9.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: If skipping program, not showing @info of start.\nFeature: @logmsg does not show module, file, line etc.","category":"page"},{"location":"changelog/#v0.9.1","page":"Change Log","title":"v0.9.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: pretty print of Pipelines types.","category":"page"},{"location":"changelog/#v0.9.0","page":"Change Log","title":"v0.9.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: run id file contain file information to guess whether files are updated and better decide rerun.\nFix: quote_function: func(a; b = b): if b is one of inputs or outputs, the first b does not change.","category":"page"},{"location":"changelog/#v0.8.6","page":"Change Log","title":"v0.8.6","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: If any file (not dir) paths of the inputs are newer than the run id file, the program will run again to update the outputs, even if the run id file exists. (#4)","category":"page"},{"location":"changelog/#v0.8.5","page":"Change Log","title":"v0.8.5","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Enchance compatibility with JobSchedulers v0.6.12: Program has a new field called arg_forward that is used to forward user-defined inputs/outputs to specific keyword arguments of JobSchedulers.Job(::Program, ...), including name::String, user::String, ncpu::Int, mem::Int.","category":"page"},{"location":"changelog/#v0.8.4","page":"Change Log","title":"v0.8.4","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: If defining a Program using Expr in other packages, the precompilation will fail due to the Expr will be @eval to a function in Pipelines. Julia does not allow define new functions in a compiled module. To avoid this, we have to pass the current module to CmdProgram or JuliaProgram. In this fix, the two methods accepts a new keyword argument mod, which allows users to pass mod = @__MODULE__ manually.","category":"page"},{"location":"changelog/#v0.8.2-3","page":"Change Log","title":"v0.8.2-3","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: New Arg data type for storing inputs and outputs information in Program. arg_inputs::Vector{Arg} and arg_outputs::Vector{Arg} are new fields of Program.\nFeature: If a Arg name of inputs/outputs is a Symbol, run id will not generate using this Arg, which is useful for args do not affect the results, such as nthread, ncpu. (#8)\nFix other issues.\nDocs: better documentation for v0.8 features.","category":"page"},{"location":"changelog/#v0.8.1","page":"Change Log","title":"v0.8.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: dictreplace!(ex::AbstractString, s::Symbol, v::Expr) is now several times faster.\nDocs: better documentation for v0.8 features.","category":"page"},{"location":"changelog/#v0.8.0","page":"Change Log","title":"v0.8.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: quote_function allows user to use 'elements of inputs and outputs as variables' when defining Program. To use the feature, users can pass quote ... end to Program's arguments that requires Function before, such as main, validate_inputs. From Pipelines v0.8, all Expr provided will be converted to Function automatically. See details in quote_expr.","category":"page"},{"location":"changelog/#v0.7.8","page":"Change Log","title":"v0.7.8","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: check_reserved_xxputs does not need xxput_types::Vector{Type}.","category":"page"},{"location":"changelog/#v0.7.7","page":"Change Log","title":"v0.7.7","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: now run(p; kwargs...) works like prog_run(p::Program; kwargs...). If original inputs, outputs are given, and same keys in kwargs... are found, the latter will override the former. If program args are conflict with other arguments, an error will throw.\nFeature: infer_outputs(prog; INPUT1 = 5) now supports run-like kwargs.\nFeature: Before creating new Program, check_reserved_xxputs and check_function_methods.","category":"page"},{"location":"changelog/#v0.7.6","page":"Change Log","title":"v0.7.6","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: replace @run in v0.7.5 with a new function prog_run(p::Program; kwargs...). The original @run only works for global variables, otherwise you need to use @eval and complicated $ to pass variables to AST.\nFix replace @vars in v0.7.5 with a non-exported function parse_program_args(p::Program; args...). It returns (inputs::Dict{String}, outputs::Dict{String}, kwargs::Tuple).","category":"page"},{"location":"changelog/#v0.7.5","page":"Change Log","title":"v0.7.5","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature (removed in v0.7.6): Simplify: new macro @run program key_value_args... run_args...: Run program without creating inputs::Dict and outputs::Dict. The inputs and outputs are provided in the form of key = value, rather than Dict.\nFeature (removed in v0.7.6): Simplify: new macro @vars program::Program key_value_args...: Return run-able (inputs::Dict, outputs::Dict) for program using key_value_args in the form of key = value.","category":"page"},{"location":"changelog/#v0.7.4","page":"Change Log","title":"v0.7.4","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: check_dependency(p::Program) return ::Bool now.\nFeature: check_dependency(p::CmdDependency; exit_when_fail::Bool = p.exit_when_fail): new argument exit_when_fail to override p.exit_when_fail.\nFeature: new function to check all CmdDependency and Program under m::Module: check_dependency(m::Module = @__MODULE__; exit_when_fail = true, verbose = true)\nFeature: new function to display dependency status: status_dependency(m::Module = @__MODULE__; exit_when_fail = false, verbose = true).","category":"page"},{"location":"changelog/#v0.7.3","page":"Change Log","title":"v0.7.3","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix a method overwrite warning when defining Base.redirect_stdout(f::Function, ::Nothing) = f(): redirectstdout and redirectstderr are the same (::Base.RedirectStdStream) at least from julia v1.7, so defining redirectstdout means redirectstderr is also defined. If diff exists in previous julia versions, check first.","category":"page"},{"location":"changelog/#v0.7.2","page":"Change Log","title":"v0.7.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: do not show the error stack traces twice (@error and rethrow()).","category":"page"},{"location":"changelog/#v0.7.1","page":"Change Log","title":"v0.7.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: the returned value of the main function of JuliaProgram does not required to be a Dict. If it is not a Dict or the returned Dict fails to pass keyword check, a warn message will be displayed and the inferred outputs will be used.\nFix: MethodError: no method matching sort(::Dict{String, Any}) in generate_run_uuid(...): import OrderedCollections.jl.\nOptimize: do not show the error messages twice when stderr is not redirected.","category":"page"},{"location":"changelog/#v0.7.0","page":"Change Log","title":"v0.7.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: generate_run_uuid: more stable way to generate run UUID using inputs and outputs.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Caution: The UUIDs generated using old versions will be out of date, so if you run the same Program with the same parameters, the program will generate a different UUID. This is why it is considered as a breaking version.","category":"page"},{"location":"changelog/#v0.6.1","page":"Change Log","title":"v0.6.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: to_xxput_dict(d::Dict): v not defined: change v to d.\nFix: xxputs_completion_and_check(p, inputs, outputs): Now, if outputs are not empty and p.infer_outputs is defined, the function will first run p.infer_outputs and then merge the result and outputs (user-input keys are kept).\nOptimize: function infer_outputs(p::Program, inputs) now works like xxputs_completion_and_check but only return outputs::Dict{String}. It does not affect user-defined function p.infer_outputs. In addition, inputs is no longer strict to Dict{String} because the it will convert to Dict{String} first.","category":"page"},{"location":"changelog/#v0.6.0","page":"Change Log","title":"v0.6.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: allow retry for failed program: run(p::Program, ...; retry = 1).\nFix: the run id file generated after a successful run is under the directory specified in run(p::Program, ...; dir = \"directory\"), if p.id_file is not an absolute path (default).\nFeature: verbose in run(p::Program, ...; verbose = :min): If true or :all, print all info and error messages. If :min, print minimum info and error messages. If false or :none, print error messages only.","category":"page"},{"location":"changelog/#v0.5.2","page":"Change Log","title":"v0.5.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: Export restore_stderr.","category":"page"},{"location":"changelog/#v0.5.1","page":"Change Log","title":"v0.5.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: stdxxx_origin set to nothing when reloading Pipelines from another module.","category":"page"},{"location":"changelog/#v0.5.0","page":"Change Log","title":"v0.5.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: stack traces of failed results.\nFix: original stdout and stderr can be recovered by using restore_stdout() and restore_stderr(). Remove set_default_stdout() and set_default_stderr() because they cause confusion sometimes.\nOptimize: default output of program info.","category":"page"},{"location":"changelog/#v0.4.6","page":"Change Log","title":"v0.4.6","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: results of isok(::AbstractString) should be expected.","category":"page"},{"location":"changelog/#v0.4.5","page":"Change Log","title":"v0.4.5","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: allow check dependencies when test argument is empty.","category":"page"},{"location":"changelog/#.4.4","page":"Change Log","title":"0.4.4","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: change DataType to Type throughout the code. It allows successful parsing of Union Type, such as \"READ1\" => Union{String, Vector{String}}.","category":"page"},{"location":"changelog/#v0.4.3","page":"Change Log","title":"v0.4.3","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix file redirecting exception when redirecting to a closed stream. Not solved: Redirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.","category":"page"},{"location":"changelog/#v0.4.2","page":"Change Log","title":"v0.4.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Better error stack trace after capturing.\nUpdate file redirecting.","category":"page"},{"location":"changelog/#v0.4.1","page":"Change Log","title":"v0.4.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix file redirecting.","category":"page"},{"location":"changelog/#v0.4.0","page":"Change Log","title":"v0.4.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: run(p::Program, ...) supports running at a specified directory (dir). Run ID files will also create at that directory.\nFeature: run(p::Program, ...) supports redirecting stdout, stderr and stdlog (Julia log output, such as @info, @warn, @error).\nFix: CmdProgram supports commands such as pipeline(cmd, stdout=stderr), which redirect stdout to stderr now because prepare_cmd(h::Base.TTY, inputs, outputs) method is added.","category":"page"},{"location":"changelog/#v0.3.2","page":"Change Log","title":"v0.3.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: CmdDependency: do not check when test_args are empty.","category":"page"},{"location":"changelog/#v0.3.1","page":"Change Log","title":"v0.3.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: to_cmd and to_str: support argument ::Regex or ::Any.","category":"page"},{"location":"changelog/#v0.3.0","page":"Change Log","title":"v0.3.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Building Program: Support type assertion and default arguments of inputs and outputs, such as \"arg\" => 5, \"arg\" => Int, \"arg\" => 5 => Int, \"arg\" => Int => 5.\nFeature: Program and run(::Program) no longer require inputs and outputs to be Vector or Dict. They can be both Vector or Dict, or even an element of Vector or Dict, as long as they can be converted. Eg:\np = CmdProgram(\n    cmd_dependencies = [julia],\n    id_file = \"id_file\",\n    inputs = [\n        \"input\",\n        \"input2\" => Int,\n        \"optional_arg\" => 5,\n        \"optional_arg2\" => 0.5 => Number\n    ],\n    outputs = \"output\" => \"<input>.output\"\n    ,\n    cmd = `echo input input2 optional_arg optional_arg2 output`\n)\n\ninputs = Dict(\n    \"input\" => `in1`,\n    \"input2\" => 2\n)\n\noutputs = [\n    \"output\" => \"out\"\n]\n\nrun(p, inputs, outputs,\n    skip_when_done = false,\n    verbose = true,\n    touch_run_id_file = false\n)\nFeature: Pretty print of Program. Eg:\njulia> p\nCmdProgram:\n  name             → Command Program\n  id_file          → id_file\n  info_before      → auto\n  info_after       → auto\n  cmd_dependencies → CmdDependency[`/usr/software/julia-1.4.2/bin/julia -Cnative -J/usr/software/julia-1.4.2/lib/julia/sys.so -O3 -g1`]\n  inputs           → \"input\"         :: Any    (required)\n                     \"input2\"        :: Int64  (required)\n                     \"optional_arg\"  :: Any    (default: 5)\n                     \"optional_arg2\" :: Number (default: 0.5)\n  validate_inputs  → do_nothing\n  prerequisites    → do_nothing\n  cmd              → `echo input input2 optional_arg optional_arg2 output`\n  infer_outputs    → do_nothing\n  outputs          → \"output\" :: Any (default: <input>.output)\n  validate_outputs → do_nothing\n  wrap_up          → do_nothing","category":"page"},{"location":"changelog/#v0.2.2","page":"Change Log","title":"v0.2.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Support JobSchedulers.jl.","category":"page"},{"location":"changelog/#v0.2.1","page":"Change Log","title":"v0.2.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix examples in docs.","category":"page"},{"location":"changelog/#v0.2.0","page":"Change Log","title":"v0.2.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"CmdDependency: Better interpolation in Cmd.\ndep::CmdDepencendy\n\n# old version\n`$(dep.exec) --args`\n# or\n`$(exec(dep)) --args`\n\n# now\n`$dep --args`\nNew JuliaProgram for pure Julia implementation.\nProgram is the Abstract type containing CmdProgram and JuliaProgram substypes.","category":"page"},{"location":"#Pipelines.jl","page":"Home","title":"Pipelines.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Pipelines","category":"page"},{"location":"","page":"Home","title":"Home","text":"A lightweight Julia package for computational pipelines.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building reusable pipelines and workflows is easier than you have ever thought.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy to build both simple and complex tasks.\nSupports external command lines and pure Julia functions.\nSupports resuming interrupted tasks, skipping finished tasks.\nSupports dependency check.\nSupports inputs, outputs validation, and so on.\nSupports program queuing and workload management with JobSchedulers.jl","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Pipelines","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pipelines","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines are built with multiple Programs. Program is the abstract type of CmdProgram and JuliaProgram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A CmdProgram contains a command template and name lists of inputs/outputs. The names of inputs/outputs will be replaced by real values when executing the program.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's set up a simple CmdProgram to print values using echo:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pipelines\n\necho = CmdProgram(\n    inputs = [\n        \"REQUIRED\",               # no default value; any data type.\n        \"TYPED\" => String,        # no default value; String type only.\n        \"OPTIONAL\" => 4,          # default value is 4; any data type.\n        \"FULL\" => String => \"abc\" # default value is abc; String type only.\n    ],\n    cmd = `echo REQUIRED TYPED OPTIONAL FULL`   \n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Running the program is just like running other Cmd,  but here we need to specify inputs in keyward arguments. Caution: use ; to split positional and keyward arguments, and do not use ,.","category":"page"},{"location":"","page":"Home","title":"Home","text":"run(echo; REQUIRED = \"Pipelines\", TYPED = \"are\", FULL = \"to build.\", OPTIONAL = :easy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Program will not run twice by default!\nThe program will generate a file (run id file) in the working directory. It records the states of all possible files (not dirs) guessed from AbstractString, FilePathsBase.AbstractPath, Base.AbstractCmd of inputs/outputs.If you run a program with the same inputs again, and any file (not dir) in inputs/outputs is not modified, the program will just return the same result, without running the program twice.input_args = (REQUIRED = \"Pipelines\", TYPED = \"are\", FULL = \"to build.\", OPTIONAL = :easy)\nrun(echo; input_args...)Several methods can be used to re-run a program:# Method 1: stop checking finished program using skip_when_done = false\nrun(echo; input_args..., skip_when_done = false)\n\n# Method 2: delete the run_id_file before running again\ncmd, run_id_file = run(echo; input_args..., dry_run = true) # Dry-run returns the command and run id file without running it.\nrm(run_id_file)  # remove the run_id_file\n\n# Method 3: Do not generate run_id_file after a successful run\nrun(echo; input_args..., touch_run_id_file=false)","category":"page"},{"location":"#Program-with-Outputs","page":"Home","title":"Program with Outputs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unlike the first example, many programs write files as outputs. Pipelines.jl has an elegant way to handle it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following program prints values simultaneously, sort them, and save to a file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prog = CmdProgram(\n    inputs = [\"INPUT1\", \"INPUT2\", \"INPUT3\"],\n    outputs = \"OUTPUT_FILE\",\n    cmd = pipeline(`echo INPUT1 INPUT2` & `echo INPUT3`, `sort`, \"OUTPUT_FILE\")\n)\n\n# inputs and outputs can be mixed together:\nrun(prog; INPUT1 = \"Good\", INPUT2 = \"Morning\", INPUT3 = \"Human\", OUTPUT_FILE = \"morning.txt\")\n\nrun(`cat morning.txt`) # print the content of out.txt\n# Good Morning\n# Human","category":"page"},{"location":"#Default-values","page":"Home","title":"Default values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Default values and data types can be set for keywords of inputs and outputs in this way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"echo = CmdProgram(\n    inputs = [\n        \"REQUIRED\",                     # no default value; any data type.\n        \"TYPED\" => String,              # no default value; String type only.\n        \"OPTIONAL\" => 5,                # default value is 5; any data type.\n        \"FULL1\" => String => \"abc\",     # default value is abc; String type only.\n        \"FULL2\" => \"abc\" => String,     # default value is abc; String type only.\n        \"INTERPOLATED\" => \"<FULL1>.xyz\" # default value is value of FULL1 * \".xyz\".\n    ],\n    cmd = `echo REQUIRED TYPED OPTIONAL FULL`   \n)","category":"page"},{"location":"#Interpolation-of-default-values","page":"Home","title":"Interpolation of default values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the default value is a String, it can be interpolated by using <keyword>, such as \"<FULL1>.xyz\" in the example.","category":"page"},{"location":"#Generate-outputs-using-Function","page":"Home","title":"Generate outputs using Function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This step is prior to adding default values of outputs, and string interpolation using <>.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We also provide a parameter (infer_outputs::Expr) in CmdProgram to generate complex outputs::Dict{String} from inputs. You can use elements in inputs as variables in Expr. The Expression will automatically converted to function. Please make sure the returned value of the function has to be a Dict{String} with keys of outputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prog = CmdProgram(\n    inputs = [\n        \"INPUT1\" => Int,\n        \"INPUT2\" => Int => 3\n    ],\n    outputs = \"OUTPUT_FILE\",\n    cmd = pipeline(`echo INPUT1 INPUT2`, `sort`, \"OUTPUT_FILE\"),\n    infer_outputs = quote\n        Dict(\"OUTPUT_FILE\" => joinpath(pwd(), string(\"out_\", INPUT1, \".txt\")))\n    end\n)\nsuccess, outputs = run(prog; INPUT1 = 5)\n# (true, Dict{String, Any}(\"OUTPUT_FILE\" => \"/home/jiacheng/projects/Pipelines.jl/out_5.txt\"))\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also generate default outputs without running the program:","category":"page"},{"location":"","page":"Home","title":"Home","text":"outputs = infer_outputs(prog; INPUT1 = 5)","category":"page"},{"location":"#Julia-Program","page":"Home","title":"Julia Program","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines also defined JuliaProgram type for pure Julia functions. It is like CmdProgram and remain most compatibility. Main difference is that it uses argument main::Expr to replace cmd::AbstractCmd in arguments. More details are in the Julia Program, Manual Page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prog = JuliaProgram(\n    inputs = [\"A\", \"B\"],\n    outputs = [\"OUT\"],\n    infer_outputs = quote\n        Dict(\"OUT\" => A + B)\n    end,\n    main = quote\n        @show A\n        @show B\n        OUT = A + B\n    end\n)\n\nrun(prog; A = 3, B = 5)\n# (true, Dict{String, Any}(\"OUT\" => 8))","category":"page"},{"location":"#Compatibility-with-JobSchedulers.jl","page":"Home","title":"Compatibility with JobSchedulers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines.jl is fully compatible with JobSchedulers.jl which is a Julia-based job scheduler and workload manager inspired by Slurm and PBS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"run(::Program, ...) can be replaced by Job(::Program, ...). The latter creates a Job, and you can submit the job to queue by using submit!(::Job).","category":"page"},{"location":"#Future-Development","page":"Home","title":"Future Development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support running competitive tasks with locks.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Program","page":"API","title":"Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Program\ninfer_outputs","category":"page"},{"location":"API/#Pipelines.Program","page":"API","title":"Pipelines.Program","text":"Summary\n\nabstract type Program <: Any\n\nSubtypes\n\nCmdProgram\nJuliaProgram\n\n\n\n\n\n","category":"type"},{"location":"API/#Pipelines.infer_outputs","page":"API","title":"Pipelines.infer_outputs","text":"infer_outputs(p::Program; input_kwargs...)\ninfer_outputs(p::Program, inputs)\ninfer_outputs(p::Program, inputs, outputs)\n\nInfer the default outputs from p::Program and inputs::Dict{String}.\n\n\n\n\n\n","category":"function"},{"location":"API/#Command-Program","page":"API","title":"Command Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CmdProgram()\nprepare_cmd","category":"page"},{"location":"API/#Pipelines.CmdProgram-Tuple{}","page":"API","title":"Pipelines.CmdProgram","text":"CmdProgram <: Program\n\nCmdProgram(;\n    name::String                            = \"Command Program\",\n    id_file::String                         = \"\",\n    info_before::String                     = \"auto\",\n    info_after::String                      = \"auto\",\n    cmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n    inputs                                  = Vector{String}(),\n    validate_inputs::Expr                   = do_nothing,  # vars of inputs\n    infer_outputs::Expr                     = do_nothing,  # vars of inputs\n    prerequisites::Expr                     = do_nothing,  # vars of inputs and outputs\n    cmd::Base.AbstractCmd                   = ``,\n    outputs                                 = Vector{String}(),\n    validate_outputs::Expr                  = do_nothing,  # vars of outputs\n    wrap_up::Expr                           = do_nothing,  # vars of inputs and outputs\n    arg_forward                             = Vector{Pair{String,Symbol}}(),\n    mod::Module                             = Pipelines    # change to @__MODULE__ to avoid precompilation error\n) -> CmdProgram\n\nCommand program template. To run a CmdProgram, use run(::CmdProgram; kwargs...).\n\nArguments\n\nname::String: Program name.\nid_file::String: The prefix of run ID file. To prevent from running the program with the same inputs and outputs twice, it will generate a unique run ID file after a successful run.\ninfo_before::String: Print it when the program is started.\ninfo_after::String: Print it when the program is finished.\ncmd_dependencies::Vector{CmdDependency}: Any command dependencies used in the program.\ninputs and outputs: Elements (or vectors containing elements) in the following format: (1) keyword (2) keyword => data_type (3) keyword => default_value (4) keyword => default_value => data_type.\nkeyword is an argument name, normally it is a String. If the keyword does not affect results (such as ncpu, nthreads), it needs to be a Symbol. When generating unique run IDs, Symbol args are ignored.default_value is optional. If set, users may not provide this argument when running. Elsewise, users have to provide it. Caution: nothing is preserved and means default value not set. If String, it can contain other keywords, but need to quote using '<>', such as \"<arg>.txt\"data_type is optional. If set, the value provided have to be this data type, or an error will throw.\nvalidate_inputs::Expr: A quoted code to validate inputs. Elements in inputs can be directly used as variables. If validation fail, throw error or return false. See details in quote_expr\ninfer_outputs::Expr: A quoted code to infer outputs from inputs. Elements in inputs can be directly used as variables. Has to return a Dict{String}(\"OUTPUT_VAR\" => value). See details in quote_expr\nprerequisites::Expr: A quoted code to run just before the main command. It prepares necessary things, such as creating directories. Elements in inputs and outputs can be directly used as variables. See details in quote_expr\ncmd::AbstractCmd: The main command template. In the template, keywords in inputs::Vector{String} and outputs::Vector{String} will be replaced when envoking run(::CmdProgram, inputs::Dict{String, ValidInputTypes}, outputs::Dict{String, ValidInputTypes}).\nvalidate_outputs::Expr: A quoted code to validate outputs. Elements in outputs can be directly used as variables. If validation fail, throw error or return false. See details in quote_expr\nwrap_up::Expr: The last quoted code to run. Elements in inputs and outputs can be directly used as variables. See details in quote_expr\narg_forward: forward args from inputs and outputs to specific keywords in JobSchedulers.Job(), only supporting Pipelines.FORWARD_KEY_SET: Set([:ncpu, :mem, :user, :name]). Elements (or vectors containing elements) in the following format: \"arg_of_inputs_or_outputs\" => :key_in_FORWARD_KEY_SET.\nmod::Module: Exprressions will evaluated to functions in mod. Please use mod = @__MODULE__ to prevent precompilation fail when defining the program within a package.\n\ncompat: Compatibility of Pipelines < v0.8\nYou can still pass Function to variables require Expr, but you cannot use the 'elements as variables' feature. The function should take inputs::Dict{String} and/or outputs::Dict{String} as variables, and you have to use traditional inputs[\"VARNAME\"] in functions.From Pipelines v0.8, all Expr provided will be converted to Function automatically.\n\ntip: Debug: variable not found\nPlease refer to quote_expr, section 'quote variables in other scopes.'\n\nExample\n\np = CmdProgram(\n    id_file = \"id_file\",\n    inputs = [\"input\",\n              \"input2\" => Int,\n              \"optional_arg\" => 5,\n              \"optional_arg2\" => 0.5 => Number],\n    outputs = \"output\" => \"<input>.output\",\n    validate_inputs = quote\n        @show optional_arg\n        optional_arg2 isa Float64 && inputs isa Dict\n    end,\n    cmd = `echo input input2 optional_arg optional_arg2 output`)\n\n# running the program: keyword arguments include keys of inputs and outputs\nsuccess, outputs = run(p; input = `in1`, input2 = 2, output = \"out\", touch_run_id_file = false)\n\n# an old way to `run` program: need to create Dicts of inputs and outputs first.\ninputs = Dict(\"input\" => `in1`,    \"input2\" => 2)\noutputs = Dict(\"output\" => \"out\")\nrun(p, inputs, outputs; touch_run_id_file = false)\n\nSee also: CmdProgram, JuliaProgram, quote_expr\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.prepare_cmd","page":"API","title":"Pipelines.prepare_cmd","text":"prepare_cmd(p::CmdProgram, inputs, outputs)\n\nPrepare the runable command. Keywords in CmdProgram will be given to values of inputs/outputs.\n\n\n\n\n\n","category":"function"},{"location":"API/#Julia-Program","page":"API","title":"Julia Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"JuliaProgram()","category":"page"},{"location":"API/#Pipelines.JuliaProgram-Tuple{}","page":"API","title":"Pipelines.JuliaProgram","text":"JuliaProgram <: Program\n\nJuliaProgram(;\n    name::String                            = \"Julia Program\",\n    id_file::String                         = \"\",\n    info_before::String                     = \"auto\",\n    info_after::String                      = \"auto\",\n    cmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n    inputs                                  = Vector{String}(),\n    validate_inputs::Expr                   = do_nothing,  # vars of inputs\n    infer_outputs::Expr                     = do_nothing,  # vars of inputs\n    prerequisites::Expr                     = do_nothing,  # vars of inputs and outputs\n    main::Expr                              = do_nothing,  # vars of inputs and outputs\n    outputs                                 = Vector{String}(),\n    validate_outputs::Expr                  = do_nothing,  # vars of outputs\n    wrap_up::Expr                           = do_nothing   # vars of inputs and outputs\n    arg_forward                             = Vector{Pair{String,Symbol}}(),\n    mod::Module                             = Pipelines    # change to @__MODULE__ to avoid precompilation error\n) -> JuliaProgram\n\nJulia program template. To run a JuliaProgram, use run(::JuliaProgram; kwargs...).\n\nArguments\n\nname::String: Program name.\nid_file::String: The prefix of run ID file. To prevent from running the program with the same inputs and outputs twice, it will generate a unique run ID file after a successful run.\ninfo_before::String: Print it when the program is started.\ninfo_after::String: Print it when the program is finished.\ncmd_dependencies::Vector{CmdDependency}: Any command dependencies used in the program.\ninputs and outputs: Elements (or vectors containing elements) in the following format: (1) keyword (2) keyword => data_type (3) keyword => default_value (4) keyword => default_value => data_type. See more: Arg.\nkeyword is an argument name, normally it is a String. If the keyword does not affect results (such as ncpu, nthreads), it needs to be a Symbol. When generating unique run IDs, Symbol args are ignored.default_value is optional. If set, users may not provide this argument when running. Elsewise, users have to provide it. Caution: nothing is preserved and means default value not set. If String, it can contain other keywords, but need to quote using '<>', such as \"<arg>.txt\"data_type is optional. If set, the value provided have to be this data type, or an error will throw.\nvalidate_inputs::Expr: A quoted code to validate inputs. Elements in inputs can be directly used as variables. If validation fail, throw error or return false. See details in quote_expr\ninfer_outputs::Expr: A quoted code to infer outputs from inputs. Elements in inputs can be directly used as variables. Has to return a Dict{String}(\"OUTPUT_VAR\" => value). See details in quote_expr\nprerequisites::Expr: A quoted code to run just before the main command. It prepares necessary things, such as creating directories. Elements in inputs and outputs can be directly used as variables. See details in quote_expr\nmain::Expr: The main julia code. Elements in inputs and outputs can be directly used as variables. See details in quote_expr\n\nwarning: Returned outputs\nThe returned value of p.main will be assigned to new outputs. Please ensure the variables in outputs are defined correctly, since it will return outputs::Dict{String,Any}.\n\nvalidate_outputs::Expr: A quoted code to validate outputs. Elements in outputs can be directly used as variables. If validation fail, throw error or return false. See details in quote_expr\nwrap_up::Expr: the last quoted code to run. Elements in inputs and outputs can be directly used as variables. See details in quote_expr\narg_forward: forward args from inputs and outputs to specific keywords in JobSchedulers.Job(), only supporting Pipelines.FORWARD_KEY_SET: Set([:ncpu, :mem, :user, :name]). Elements (or vectors containing elements) in the following format: \"arg_of_inputs_or_outputs\" => :key_in_FORWARD_KEY_SET.\nmod::Module: Exprressions will evaluated to functions in mod. Please use mod = @__MODULE__ to prevent precompilation fail when defining the program within a package.\n\ncompat: Compatibility of Pipelines < v0.8\nYou can still pass Function to variables require Expr, but you cannot use the 'elements as variables' feature. The function should take inputs::Dict{String} and/or outputs::Dict{String} as variables, and you have to use traditional inputs[\"VARNAME\"] in functions.From Pipelines v0.8, all Expr provided will be converted to Function automatically.\n\ntip: Debug: variable not found\nPlease refer to quote_expr, section 'quote variables in other scopes.'\n\nExample\n\np = JuliaProgram(\n    id_file = \"id_file\",\n    inputs = [\"a\",\n              \"b\" => Int],\n    outputs = \"c\" => \"<a>.<b>\",\n    main = quote\n        println(\"inputs are \", a, \" and \", b)\n        println(\"You can also use info in outputs: \", c)\n        println(\"The returned value will be assigned to a new outputs\")\n        c = b^2\n    end)\n\n# running the program: keyword arguments include keys of inputs and outputs\nsuccess, new_out = run(p; a = `in1`, b = 2, c = \"out\", touch_run_id_file = false)\n\n@assert new_out != infer_outputs(p; a = `in1`, b = 2, c = \"out\")  # outputs will change to the returned value of main function, if the returned value is a Dict and pass `p.validate_outputs`\n\n# an old way to `run` program: need to create Dicts of inputs and outputs first.\ninputs = Dict(\"a\" => `in1`, \"b\" => 2)\noutputs = \"c\" => \"out\"\nsuccess, new_out = run(p, inputs, outputs; touch_run_id_file = false)\n\n\n\n\n\n","category":"method"},{"location":"API/#Quote-for-Program","page":"API","title":"Quote for Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"quote_expr\nquote_function","category":"page"},{"location":"API/#Pipelines.quote_expr","page":"API","title":"Pipelines.quote_expr","text":"quote\n    do_some_thing()\nend :: Expr\n\nquote creates a piece of code without using the explicit Expr constructor.\n\nFrom Pipelines v0.8, you can use quote ... end to validate_inputs, infer_outputs, do prerequisites, do main, validate_outputs, and wrap_up a Program.\n\nElements in inputs or outputs can be directly used as variables for those arguments. See the table below.\n\nArgument Elements as variables Default returned value\nvalidate_inputs inputs the last expression\ninfer_outputs inputs the last expression, can converted to Dict{String}\nprerequisites inputs, outputs the last expression\nmain (JuliaProgram only) inputs, outputs outputs::Dict{String}\nvalidate_outputs outputs the last expression\nwrap_up inputs, outputs the last expression\n\nExample\n\nprog = JuliaProgram(\n    inputs = [\"A\", \"B\"],\n    outputs = [\"OUT\"],\n    validate_inputs = quote\n        @show A\n        @show inputs\n        A isa Number\n    end,\n    infer_outputs = quote\n        Dict(\"OUT\" => A + B)\n    end,\n    main = quote\n        @show A\n        @show B\n        OUT = A + B\n    end,\n    validate_outputs = quote\n        @show OUT\n        OUT isa Number\n    end\n)\n\nrun(prog; A = 3, B = 5, touch_run_id_file = false)\n# (true, Dict{String, Any}(\"OUT\" = 8))\n\nwarning: `quote` variables in other scopes\nA local variable (include function) should be referenced using $ in expression. (No need to use $ for global variables.)\nA local ::Symbol variable (sym) should be referenced using $(QuoteNode(sym)) in expression.Example:inputs = [\"A\", \"B\"]\ng_var = 3\ng_sym = :globalsymbol\n\nfunction gen_expr()\n    l_var = 5\n    l_func() = @info(\"Use local function\")\n    l_sym = :abc\n    expr = quote\n        @show inputs\n        @show g_var\n        @show g_sym\n        @show $(QuoteNode(l_sym))\n        @show $l_var + 2\n        $l_func()\n        A + B\n    end\nend\n\nexpr = gen_expr()\nfunc = Pipelines.quote_function(expr, inputs; mod = @__MODULE__)\n\nin_dict = Dict(\"A\" => 5, \"B\" => 50)\nfunc(in_dict)\n\ncompat: Compatibility of Pipelines < v0.8\nYou can still pass Function to variables require Expr, but you cannot use the 'elements as variables' feature. The function should take inputs::Dict{String} and/or outputs::Dict{String} as variables, and you have to use traditional inputs[\"VARNAME\"] in functions.\n\nSee also: CmdProgram, JuliaProgram, quote_function\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.quote_function","page":"API","title":"Pipelines.quote_function","text":"quote_function(expr::Expr, inputs::Vector{String}; specific_return = nothing, mod::Module = Pipelines)\n    # Return `Function` with one argument: `inputs::Dict{String}`.\n\nquote_function(expr::Expr, inputs::Vector{String}, outputs::Vector{String}; specific_return = nothing, mod::Module = Pipelines)\n    # Return `Function` with two arguments: `inputs::Dict{String}, outputs::Dict{String}`.\n\nquote_function(f::Function, x; specific_return, mod) = f\nquote_function(f::Function, x, y; specific_return, mod) = f\n    # Directly return `f::Function` without any process.\n\nDescription\n\nWhen building Program, Expr are automatically converted to Function using quote_function. The elements of inputs and/or outputs in expr will be replaced by inputs[\"element\"] and/or outputs[\"elements\"], respectively. Also, in the generated function, the arguments (inputs and outputs) are regarded as Dict{String}.\n\nspecific_return: an Expr appended to expr.\nmod::Module: Exprressions will evaluated to functions in mod. Please use mod = @__MODULE__ to prevent precompilation fail when defining the program within a package.\n\nIn expr::Expr, elements in inputs or outputs can be directly used as variables for those arguments. See the table below.\n\nArgument Elements as variables Default returned value\nvalidate_inputs inputs the last expression\ninfer_outputs inputs the last expression, can be converted to Dict{String}\nprerequisites inputs, outputs the last expression\nmain (JuliaProgram only) inputs, outputs outputs::Dict{String}\nvalidate_outputs outputs the last expression\nwrap_up inputs, outputs the last expression\n\nUsage in Program building\n\nfunction JuliaProgram(; kwargs...)\n    ...\n    # inputs isa Vector{String}\n    # outputs isa Vector{String}\n    # mod isa Module where evaluating expressions to functions in\n\n    validate_inputs = quote_function(validate_inputs, inputs; mod = mod)\n    infer_outputs = quote_function(infer_outputs, inputs; mod = mod)\n    prerequisites = quote_function(prerequisites, inputs, outputs; mod = mod)\n    validate_outputs = quote_function(validate_outputs, outputs; mod = mod)\n    wrap_up = quote_function(wrap_up, inputs, outputs; mod = mod)\n\n    main = quote_function(main, inputs, outputs; specific_return = :(outputs), mod = mod)\n    ...\nend\n\n\n\n\n\n","category":"function"},{"location":"API/#Arg","page":"API","title":"Arg","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Arg\nPipelines.RESERVED_KEY_SET\nPipelines.FORWARD_KEY_SET","category":"page"},{"location":"API/#Pipelines.Arg","page":"API","title":"Pipelines.Arg","text":"\nArg(name)\nArg(name => default)\nArg(name => type::Type)\nArg(name => default => type::Type)\nArg(name => type::Type => default)\n\nArg(name::Union{String,Symbol}, type::Type = Any, default = nothing;\n    required::Bool = isnothing(default),\n    independent::Bool = name isa Symbol\n)\n\nstruct Arg{type,DefaultType}\n    name::String\n    type::Type\n    default::DefaultType\n    required::Bool\n    independent::Bool\nend\n\nArg stores the settings of inputs and outputs in Program.\n\nname: name of Arg.\ntype: allowed type.\ndefault: default value.\nrequired = isnothing(default): if true, the Arg has to be provided by users.\nindependent = isa(name, Symbol): if true, the argument does not change the results of a Program, such as \"nthreads\", \"memory\". Independent args have no effect on run id.\n\nValid pair types\n\nname: no default value.\nname => default: set default value, except value is nothing (default value not set).\nname => type: no default value, but value type is restricted.\nname => default => type: set default value and value type.\nname => type => default: set default value and value type.\n\ntip: An edge situation\nTo create an argument with a default value of nothing, you cannot use =>. Instead, this works:p = JuliaProgram(\n    inputs = [\n        Arg(\"ARG_NAME\", nothing; required = false),\n        \"OTHER_ARG\" => String\n    ]\n)\n\n\n\n\n\n","category":"type"},{"location":"API/#Pipelines.RESERVED_KEY_SET","page":"API","title":"Pipelines.RESERVED_KEY_SET","text":"const RESERVED_KEY_SET = Set([\"name\", \"user\", \"ncpu\", \"mem\",\n    \"schedule_time\", \"wall_time\", \"priority\", \"dependency\",\n    \"stdout\", \"stderr\", \"stdlog\", \"append\", \"dir\", \"inputs\", \"outputs\",\n    \"check_dependencies\", \"skip_when_done\", \"touch_run_id_file\",\n    \"verbose\", \"retry\", \"dry_run\"])\n\nReserved keys that cannot be used in inputs and outputs.\n\n\n\n\n\n","category":"constant"},{"location":"API/#Pipelines.FORWARD_KEY_SET","page":"API","title":"Pipelines.FORWARD_KEY_SET","text":"FORWARD_KEY_SET = Set([:name, :user, :ncpu, :mem])\n\nProgram objects has a field arg_forward. It can forward args from inputs and outputs to JobSchedulers.Job(), only supporting keyword arguments in Pipelines.FORWARD_KEY_SET. arg_forward accepts elements (or vectors containing elements) in the following format: \"arg_of_inputs_or_outputs\" => :key_in_FORWARD_KEY_SET.\"\n\n\n\n\n\n","category":"constant"},{"location":"API/#Run-Program","page":"API","title":"Run Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Base.run","category":"page"},{"location":"API/#Base.run","page":"API","title":"Base.run","text":"run(p::Program; kwargs...)\nrun(p::Program, inputs, outputs; kwargs...)\nrun(p::Program, inputs; kwargs...) # only usable when `p.infer_outputs` is defined, or default outputs are set in `p`.\n\nRun Program (CmdProgram or JuliaProgram).\n\nReturn (success::Bool, outputs::Dict{String})\n\nwarning: Warning\nIf p isa JuliaProgram, outputs will be overwritten by the returned value of p.main only when the returned value is a Dict{String} and passes p.validate_outputs. See more at JuliaProgram.\n\nPositional Arguments\n\np::Program: the command or Julia program template.\ninputs and outputs: p::Program stores a program template with replaceable portions as keywords. All keywords can be found at p.arg_inputs and p.arg_outputs. Here, inputs and outputs are better to be Dict(keyword::String => replacement).\nIf data types of inputs and outputs are not Dict{String}, they will be converted as far as possible. If the conversion fails, program will throw an error.\n\nKeyword Arguments:\n\nelements in p.arg_inputs and p.arg_outputs. They will merge to positional arguments inputs and outputs.\ndir::AbstractString = \"\": working directory to run the program and store run_id_file.\ncheck_dependencies::Bool = true: check dependencies for p (p.cmd_dependencies).\nskip_when_done::Bool = true: Skip running the program and return true if it has been done before (the run_id_file exists and p.validate_outputs(outputs) passes.)\ntouch_run_id_file::Bool = true: If true, touch a unique run ID file, which indicate the program is successfully run with given inputs and outputs. If false, the next time running the program, skip_when_done=true will not take effect.\nverbose = true: If true or :all, print all info and error messages. If :min, print minimum info and error messages. If false or :none, print error messages only.\nretry::Int = 0: If failed, retry for INT times.\ndry_run::Bool = false: do not run the program, return (command::AbstractCmd, run_id_file::String) for CmdProgram, or (inferred_outputs::Dict{String}, run_id_file::String) for JuliaProgram.\nstdout, stderr, stdlog and append::Bool = false: Redirect the program outputs to files. stdlog is the Julia logging of @info, @warn, @error, etc. Caution: If p isa CmdProgram and the original command (p.cmd) has redirection, arguments defined here might not be effective for the command.\n\nwarning: Thread safety\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.\n\nWorkflow\n\nGo to the working directory. Establish redirection. (dir, stdout, stderr, stdlog, append).\nValidate compatibility between p and inputs/outputs.\nCheck whether the program has run before. (skip_when_done, p.validate_outputs)\nCheck command dependencies. (check_dependencies, p.cmd_dependencies)\nValidate inputs. (p.validate_inputs)\n[CmdProgram only] Generate runnable command from p and inputs/outputs. (stdout, stderr, append)\nPreparing before running main command. (p.prerequisites)\nRun command [CmdProgram] or the main function [JuliaProgram].\nIf p isa CmdProgram, validate outputs only. If p isa JuliaProgram, validate the returned value of the main function. If pass, outputs will overwritten by the returned value. Otherwise, the original outputs is kept. (p.validate_outputs)\nWrap up. (p.wrap_up)\nSuccess, touch run id file, and return (success::Bool, outputs::Dict{String}). (touch_run_id_file::Bool)\n\nExample\n\np = JuliaProgram(\n    id_file = \"id_file\",\n    inputs = [\"a\",\n              \"b\" => Int],\n    outputs = \"c\" => \"<a>.<b>\",\n    main = quote\n        println(\"inputs are \", a, \" and \", b)\n        println(\"You can also use info in outputs: \", outputs[\"c\"])\n        println(\"The returned value will be assigned to a new outputs\")\n        println(\"It is ok to use inputs and outputs directly:\")\n        @show inputs\n        @show outputs\n        c = b^2\n    end)\n\n# running the program using `run`: keyword arguments include keys of inputs and outputs\nsuccess, new_out = run(p; a = `in1`, b = 2, c = \"out\", touch_run_id_file = false)\n\n# an old way to `run` program: need to create inputs and outputs first.\ninputs = Dict(\"a\" => `in1`, \"b\" => 2)\noutputs = \"c\" => \"out\"\nsuccess, new_out = run(p, inputs, outputs; touch_run_id_file = false)\n\n# for CmdProgram, outputs are inferred before running the main command, however,\n# for JuliaProgram, outputs will change to the returned value of main function, if the returned value is a Dict and pass `p.validate_outputs`\n@assert new_out != outputs\n\n\n\n\n\n\n\n","category":"function"},{"location":"API/#Command-Dependency","page":"API","title":"Command Dependency","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CmdDependency\ncheck_dependency\ncheck_dependency_dir(path::AbstractString; exit_when_false=true)\ncheck_dependency_file(path::AbstractString; exit_when_false=true)","category":"page"},{"location":"API/#Pipelines.CmdDependency","page":"API","title":"Pipelines.CmdDependency","text":"Struct\n\nmutable struct CmdDependency\n    exec::Base.Cmd\n    test_args::Base.Cmd\n    validate_success::Bool\n    validate_stdout::Function\n    validate_stderr::Function\n    exit_when_fail::Bool\nend\n\nMethods\n\nCmdDependency(;\n    exec::Base.Cmd=``,\n    test_args::Base.Cmd=``,\n    validate_success::Bool=false,\n    validate_stdout::Function=do_nothing,\n    validate_stderr::Function=do_nothing,\n    exit_when_fail::Bool=true\n)\n\nCreate Command Dependency (CmdDependency).\n\nArguments\n\nexec::AbstractCmd: the command to call the dependency.\ntest_args::AbstractCmd: for testing purposes, the command to be appended to exec.\nvalidate_success::Bool: when checking the dependency, whether to validate the exit code == 0.\nvalidate_stdout::Function: a function takes standard out as String and return the validation result as ::Bool.\nvalidate_stderr::Function: a function takes standard error as String and return the validation result as ::Bool.\nexit_when_fail::Bool: if validation fails, whether to throw error and exit.\n\nExample\n\njulia = CmdDependency(\n    exec = Base.julia_cmd(),\n    test_args = `--version`,\n    validate_success = true,\n    validate_stdout = x -> occursin(r\"^julia version\", x),\n    validate_stderr = do_nothing,\n    exit_when_fail = true\n)\n\ncheck_dependency(julia)\n\n\n\n\n\n","category":"type"},{"location":"API/#Pipelines.check_dependency","page":"API","title":"Pipelines.check_dependency","text":"check_dependency(p::CmdDependency; exit_when_fail::Bool = p.exit_when_fail) -> Bool\n\nCheck CmdDependency by evaluating:\n\n`$(p.exec) $(p.test_args)`\n\nIf success, return true.\n\nIf fail, return false, or throw DependencyError when exit_when_fail set to true.\n\n\n\n\n\ncheck_dependency(p::Program; exit_when_fail::Bool=true)\n\nCheck dependencies listed in p.cmd_dependencies.\n\n\n\n\n\ncheck_dependency(m::Module = @__MODULE__; exit_when_fail = true, verbose = true)\n\nCheck all CmdDependency and Program under m::Module.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.check_dependency_dir-Tuple{AbstractString}","page":"API","title":"Pipelines.check_dependency_dir","text":"check_dependency_dir(path::Union{AbstractString,Cmd}; exit_when_false=true) -> Bool\n\nChecke whether a directory exists. Return ::Bool.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.check_dependency_file-Tuple{AbstractString}","page":"API","title":"Pipelines.check_dependency_file","text":"check_dependency_file(path::Union{AbstractString,Cmd}; exit_when_false=true) -> Bool\n\nChecke whether a file exists. Return ::Bool.\n\n\n\n\n\n","category":"method"},{"location":"API/#Common-Methods","page":"API","title":"Common Methods","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"status_dependency","category":"page"},{"location":"API/#Pipelines.status_dependency","page":"API","title":"Pipelines.status_dependency","text":"status_dependency(m::Module = @__MODULE__; exit_when_fail = false, verbose = true)\n\nCheck all CmdDependency and Program under m::Module. Similar to check_dependency, but do not exit_when_fail by default.\n\n\n\n\n\n","category":"function"},{"location":"API/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"replaceext(::String, ::AbstractString)\nremoveext(::String)\nsplit(::Cmd)\nto_str(::Cmd)\nto_cmd(::Cmd)\ndo_nothing\nisok","category":"page"},{"location":"API/#Pipelines.replaceext-Tuple{String, AbstractString}","page":"API","title":"Pipelines.replaceext","text":"replaceext(path, replacement::AbstractString)\n\nIf the last component of a path contains a dot, leave everything before the dot as usual, and everything after the dot is replaced by replacement. Otherwise, replacement will be appended to path.\n\nIf replacement is empty, the last dot will be removed.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.removeext-Tuple{String}","page":"API","title":"Pipelines.removeext","text":"removeext(path)\n\nIf the last component of a path contains a dot, leave everything before the dot as usual, and everything including and after the dot is discarded.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.split-Tuple{Cmd}","page":"API","title":"Base.split","text":"split(c::Cmd) = c.exec :: Vector{String}\n\nReturn splitted arguments of Cmd.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.to_str-Tuple{Cmd}","page":"API","title":"Pipelines.to_str","text":"to_str(x) -> String\nstr(x) -> String\n\nConvert x to String.\n\nx::Cmd: remove backticks (return string(x)[2:end-1]).\nx::Nothing: return \"\".\nx::Vector: join elements with \"_\" as delim.\nx::Any: return string(x).\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.to_cmd-Tuple{Cmd}","page":"API","title":"Pipelines.to_cmd","text":"to_cmd(x) -> Cmd\n\nConvert x to Cmd.\n\nException: when x::Nothing, return nothing::Nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.do_nothing","page":"API","title":"Pipelines.do_nothing","text":"do_nothing() = nothing\ndo_nothing(x) = nothing\ndo_nothing(x, y) = nothing\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.isok","page":"API","title":"Pipelines.isok","text":"isok(x::Nothing) = true\nisok(x::Bool) = x\nisok(x::AbstractString) = true unless x is \"\" / n / no / null / f / false / 0\nisok(x::Any) = true  # default is true\n\n\n\n\n\n","category":"function"},{"location":"API/#Redirection","page":"API","title":"Redirection","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"redirect_to_files\nrestore_stdout\nrestore_stderr","category":"page"},{"location":"API/#Pipelines.redirect_to_files","page":"API","title":"Pipelines.redirect_to_files","text":"redirect_to_files(f::Function, file; mode=\"a+\")\nredirect_to_files(f::Function, outfile, errfile; mode=\"a+\")\nredirect_to_files(f::Function, outfile, errfile, logfile; mode=\"a+\")\n\nRedirect outputs of function f to file(s).\n\nxxxfile: File path (AbstractString), nothing or ::IO. nothing means no redirect. Files can be the same.\nmode: same as open(..., mode).\n\nCaution: If xxxfile is an IO, it won't be closed. Please use close(io) or JobSchedulers.close_in_future(io, jobs) manually!\n\nwarning: Thread safety\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.restore_stdout","page":"API","title":"Pipelines.restore_stdout","text":"restore_stdout()\n\nRestore the current stdout to the original stdout. It is useful when redirecting stdout/stderr fails when calling redirect_to_files, which happens when an old stream is closed and then redirected to.\n\nwarning: Thread safety\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.\n\nSee also restore_stderr().\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.restore_stderr","page":"API","title":"Pipelines.restore_stderr","text":"restore_stderr()\n\nRestore the current stderr to the original stderr. It is useful when redirecting stdout/stderr fails when calling redirect_to_files, which happens when an old stream is closed and then redirected to.\n\nwarning: Thread safety\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.\n\nSee also restore_stdout().\n\n\n\n\n\n","category":"function"},{"location":"API/#Run-ID-File","page":"API","title":"Run ID File","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pipelines.RUN_ID_LINE_SKIP_EXTENSION\nPipelines.CMD_FILE_SPLITER\nPipelines.create_run_id_file\nPipelines.cmd_to_run_id_lines\nPipelines.need_rerun\nPipelines.any_file_differ","category":"page"},{"location":"API/#Pipelines.RUN_ID_LINE_SKIP_EXTENSION","page":"API","title":"Pipelines.RUN_ID_LINE_SKIP_EXTENSION","text":"RUN_ID_LINE_SKIP_EXTENSION = [\".so\", \".dylib\", \".dll\"]\n\nIf a file with an extension listed, run_id_file skip storing information of this file. It means whether to re-run a program, the state of the file will be ignored.\n\nSee also: Pipelines.create_run_id_file, Pipelines.cmd_to_run_id_lines, Pipelines.CMD_FILE_SPLITER\n\n\n\n\n\n","category":"constant"},{"location":"API/#Pipelines.CMD_FILE_SPLITER","page":"API","title":"Pipelines.CMD_FILE_SPLITER","text":"CMD_FILE_SPLITER = [',', ';', ':']\n\nIt is aimed to guess whether an argument of a command contain multiple file names joined using file splitters. \n\nSee also: Pipelines.create_run_id_file, Pipelines.cmd_to_run_id_lines, Pipelines.RUN_ID_LINE_SKIP_EXTENSION\n\n\n\n\n\n","category":"constant"},{"location":"API/#Pipelines.create_run_id_file","page":"API","title":"Pipelines.create_run_id_file","text":"create_run_id_file(run_id_file::AbstractString, inputs::Dict, outputs::Dict)\n\nCreate run id file.\n\nWhat is run id file\n\nThe run id file stores information of arguments and files related to a successful run of Program.\n\nBy comparing the run id file, we can determine whether we need to re-run a finished program.\n\nFile Name\n\nThe name of a run id file is <dir>/<program_id_prefix>.<argument_UUID>.\n\ndir: working directory to run the program, which can be defined in run(::Program; dir = \"\")\nprogram_id_prefix: the prefix of run ID file, which can be defined in CmdProgram(id_file = \"\") and JuliaProgram(id_file = \"\")\nargument_UUID: a unique ID generated from string representations of inputs and outputs arguments using the internal function generate_run_uuid.\n\nIn this way, the name of a run id file will not change if running a program in the same directory with same inputs and outputs.\n\nHowever, this is not enough for determine whether a job needs re-run. Consider this situation:\n\n(1) Run prog with arg = 1, output \"out.txt\" and \"run_id_file_with_arg1\"  (2) Run prog with arg = 2, output \"out.txt\" and \"run_id_file_with_arg2\"  (3) Run prog with arg = 1 again, no re-run because \"out.txt\" and \"run_id_file_with_arg1\" all exist!  \n\nTo solve the issue, we need to store the states of inputs and outputs arguments.\n\nHere, we guess file names from inputs and outputs. \n\nIf an argument is AbstractString or AbstractPath, and isfile() returns true, we store the file information. (We ignore directories because their contents are easy to change.)\nIf an argument is Base.AbstractCmd, we decompose the command into pieces, and check whether each piece is a file path. The rules of file guessing are complicated and mentioned in Pipelines.cmd_to_run_id_lines and Pipelines.CMD_FILE_SPLITER.\nIf a file name is found, and its extension is not one of Pipelines.RUN_ID_LINE_SKIP_EXTENSION, it will write to run id file.\n\nnote: Control file name guessing\nPipeline developers usually know what file extension should be ignored, and whether they have an argument joining two files with a splitter. In this way, we can use IN-PLACE methods to change Pipelines.RUN_ID_LINE_SKIP_EXTENSION and Pipelines.CMD_FILE_SPLITER. IN-PLACE methods are usually functions ending with !, such as empty!, push!, deleteat!\n\nContents of run id file\n\nTab delimited, no header.\nColumn 1: i or o stands for inputs or outputs.\nColumn 2: unix timestamp of when the file was last modified in Float64.\nColumn 3: the size (in bytes) of the file.\nColumn 3: key name of inputs or outputs. It may have duplication.\nColumn 4: file path. It may have duplication.\n\nLimitation\n\nWe cannot store states of all arguments. If we have a pure JuliaProgram without reading and writing files, we cannot guarantee the state of the arguments.\n\nA work-around is to intentionally create a file with a fixed name, and the file name is defined in Program's outputs.\n\nSee also\n\nPipelines.cmd_to_run_id_lines, Pipelines.RUN_ID_LINE_SKIP_EXTENSION, Pipelines.CMD_FILE_SPLITER\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.cmd_to_run_id_lines","page":"API","title":"Pipelines.cmd_to_run_id_lines","text":"cmd_to_run_id_lines(io::IO, arg_name::AbstractString, cmd::Base.AbstractCmd, first_char::String)\n\nio: IO of run id file.\narg_name: name of the inputs/outputs argument.\ncmd: Subtypes of Base.AbstractCmd.\nfirst_char: \"i\" or \"o\", stands for inputs or outputs.\n\nRules to guess file names from command:\n\nThe first argument is ignored because usually it is a script.\nNumbers are ignored.\nIf an argument starts with -, matching r\"^-[A-Za-z0-9\\-\\_]+(/.+)\" and r\"^-[A-Za-z0-9\\-\\_]+=(.+)\" only. If matched, go to the next rule.\nCheck whether an arg is a file. If not, try to use Pipelines.CMD_FILE_SPLITER to split the argument, and check each part. If found a file, go to the next rule.\nIf a file name is found, and its extension is not one of Pipelines.RUN_ID_LINE_SKIP_EXTENSION, it will write to run id file.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.need_rerun","page":"API","title":"Pipelines.need_rerun","text":"need_rerun(p::Program, run_id_file::AbstractString, inputs::Dict, outputs::Dict) -> Bool\n\nCheck whether re-run the program p. Return true means it need re-run.\n\nDecision details\n\nIs run_id_file a file? If not, re-run.\nRun p.validate_outputs(outputs). If fail, re-run.\nComparing status of files in run_id_file using Pipelines.any_file_differ. If yes, re-run.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.any_file_differ","page":"API","title":"Pipelines.any_file_differ","text":"any_file_differ(run_id_file::AbstractString, inputs::Dict, outputs::Dict)\n\nCheck whether any existing file (not dir) path of AbstractString or AbstractPath differ from records in run_id_file.\n\n\n\n\n\n","category":"function"},{"location":"API/#Internal","page":"API","title":"Internal","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pipelines.parse_arg\nPipelines.to_xxput_dict\nPipelines.try_function\nPipelines.StackTraceVector\nPipelines.keyword_interpolation\nPipelines.xxputs_completion_and_check\nPipelines.parse_program_args","category":"page"},{"location":"API/#Pipelines.parse_arg","page":"API","title":"Pipelines.parse_arg","text":"parse_arg(v)\n\nParsing inputs and outputs when creating Program objects.\n\nReturn Vector{Arg}.\n\nValid v element types\n\nname: no default value.\nname => value: set default value, except value is nothing (default value not set).\nname => value_type::Type: no default value, but value type.\nname => value => value_type::Type: set default value and value type.\nname => value_type::Type => value: set default value and value type.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.to_xxput_dict","page":"API","title":"Pipelines.to_xxput_dict","text":"to_xxput_dict(p::Pair{String, V}) where V\nto_xxput_dict(p::Pair)\nto_xxput_dict(v::Vector{V}) where V <: Pair\nto_xxput_dict(d::Dict)\n\nConvert inputs/outputs to Dict{String} in run(p, inputs, outputs)\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.try_function","page":"API","title":"Pipelines.try_function","text":"try_function(f::Function, error_io::IO)\ntry_function(f::Function, ::Nothing   )\n\nTry to run f. If f throws error, display stacktraces in error_io or stderr, and return stacktrace information stored as ::StackTraceVector.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.StackTraceVector","page":"API","title":"Pipelines.StackTraceVector","text":"struct StackTraceVector\n    x::Vector\nend\n\nx = [(exception,backtrace), ...]: the result of Base.current_exceptions() in Julia 1.7 or Base.catch_stack() in Julia 1.1-1.6.\n\n\n\n\n\n","category":"type"},{"location":"API/#Pipelines.keyword_interpolation","page":"API","title":"Pipelines.keyword_interpolation","text":"keyword_interpolation(inputs::Dict{String}, outputs::Dict{String})\n\nInterpolate <keyword> in String.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.xxputs_completion_and_check","page":"API","title":"Pipelines.xxputs_completion_and_check","text":"xxputs_completion_and_check(p::Program, inputs, outputs)\n\nCheck and complete inputs using types and values stored in p.\nRun p.infer_outputs if defined, and then merge it and outputs (user-input keys are kept).\nCheck and complete outputs using types and values stored in p.\nCheck keyword consistency using p.\nInterpolate <keyword> in String in completed inputs and outputs.\nReturn inputs and outputs.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.parse_program_args","page":"API","title":"Pipelines.parse_program_args","text":"parse_program_args(p::Program; args...)\n\nClassify args... to inputs and outputs of p, and other keyword arguments. args includes inputs = ..., and outputs = ...\n\nReturn (inputs::Dict{String}, outputs::Dict{String}, other_kwargs::Tuple)\n\n\n\n\n\n","category":"function"}]
}

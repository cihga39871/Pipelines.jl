var documenterSearchIndex = {"docs":
[{"location":"command_dependency/#Command-Dependency","page":"Command Dependency","title":"Command Dependency","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"Command Dependency (CmdDependency) is the external dependent program that can be used in Command Program (CmdProgram).","category":"page"},{"location":"command_dependency/#Create","page":"Command Dependency","title":"Create","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"CmdDependency(;\n    exec::Base.AbstractCmd=``,\n    test_args::Base.AbstractCmd=``,\n    validate_success::Bool=false,\n    validate_stdout::Function=do_nothing,\n    validate_stderr::Function=do_nothing,\n    exit_when_fail::Bool=true\n)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"exec::AbstractCmd: the command to call the dependency.\ntest_args::AbstractCmd: for testing purposes, the command to be appended to exec.\nvalidate_success::Bool: when checking the dependency, whether to validate the exit code == 0.\nvalidate_stdout::Function: a function takes standard out as String and return the validation result as ::Bool.\nvalidate_stderr::Function: a function takes standard error as String and return the validation result as ::Bool.\nexit_when_fail::Bool: if validation fails, whether to throw error and exit.","category":"page"},{"location":"command_dependency/#Example","page":"Command Dependency","title":"Example","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"julia = CmdDependency(\n    exec = `julia`,\n    test_args = `--version`,\n    validate_success = true,\n    validate_stdout = x -> occursin(r\"^julia version\", x),\n    validate_stderr = do_nothing,\n    exit_when_fail = true\n)","category":"page"},{"location":"command_dependency/#Check","page":"Command Dependency","title":"Check","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"CmdDependency can be checked manually by using","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"check_dependency(p::CmdDependency)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"Usually, it is not necessary when you specify CmdDependency in CmdProgram because dependency check will be done when running CmdProgram by default.","category":"page"},{"location":"command_dependency/#Use-with-CmdProgram","page":"Command Dependency","title":"Use with CmdProgram","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"When building CmdProgram, we can specify our command dependencies by using","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"dep1 = CmdDependency(...)\ndep2 = CmdDependency(...)\n\nprog = CmdProgram(\n    cmd_dependencies = [dep1, dep2],\n    ...\n)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"To call the dependency in command, we can prepend a dollor sign ($):","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"prog = CmdProgram(\n    cmd_dependencies = [dep1, dep2],\n    cmd = `$dep1 --args` & `$dep2 --args`\n)","category":"page"},{"location":"command_dependency/#An-Example","page":"Command Dependency","title":"An Example","text":"","category":"section"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"We use the same example in Command Program page.","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"Adding samtools and bowtie2 as the dependencies of the bowtie2 mapping program:","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"SAMTOOLS = CmdDependency(\n    exec = `samtools`,\n    test_args = `--version`,\n    validate_success = true,\n    validate_stdout = x -> occursin(r\"^samtools \\d+\", x)\n)\n\nBOWTIE2 = CmdDependency(\n    exec = `bowtie2`,\n    test_args = `--version`,\n    validate_success = true,\n    validate_stdout = x -> occursin(r\"bowtie2-align-s version \\d+\", x)\n)\n\nprogram_bowtie2 = CmdProgram(\n    name = \"Bowtie2 Mapping\",\n    id_file = \".bowtie2\",\n\n    cmd_dependencies = [SAMTOOLS, BOWTIE2],\n\n    inputs = [\"FASTQ\", \"REF\"],\n    validate_inputs = inputs -> begin\n        check_dependency_file(inputs[\"FASTQ\"]) &&\n        check_dependency_file(inputs[\"REF\"])\n    end,\n\n    prerequisites = (inputs, outputs) -> begin\n        mkpath(dirname(to_str(outputs[\"BAM\"])))\n    end,\n\n    outputs = [\"BAM\"],\n    infer_outputs = inputs -> begin\n        Dict(\"BAM\" => str(inputs[\"FASTQ\"]) * \".bam\")\n    end,\n    validate_outputs = outputs -> begin\n        check_dependency_file(outputs[\"BAM\"])\n    end,\n\n    cmd = pipeline(`$BOWTIE2 -x REF -q FASTQ`, `$SAMTOOLS sort -O bam -o BAM`),\n\n    wrap_up = (inputs, outputs) -> run(`$SAMTOOLS index $(outputs[\"BAM\"])`)\n)","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"To run the program, we can decide whether to check dependencies with run(..., check_dependencies=true):","category":"page"},{"location":"command_dependency/","page":"Command Dependency","title":"Command Dependency","text":"inputs = Dict(\"FASTQ\" => \"a.fastq\", \"REF\" => \"ref.fasta\")\nsuccess, outputs = run(program_bowtie2, inputs; check_dependencies = true)","category":"page"},{"location":"julia_program/#Julia-Program","page":"Julia Program","title":"Julia Program","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"Please read the Command Program section in Manual page first.","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"Pipelines are built with multiple Programs. Program is the abstract type contains CmdProgram and JuliaProgram.","category":"page"},{"location":"julia_program/#Differences-between-CmdProgram-and-JuliaProgram","page":"Julia Program","title":"Differences between CmdProgram and JuliaProgram","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"JuliaProgram and CmdProgram are generally the same and remain most compatibility, except for the differences:","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"Diff cp :: CmdProgram jp :: JuliaProgram\nUnique Field cp has a command template: cp.cmd::AbstractCmd jp has a main Julia function: jp.main::Function\nMethod to Run Replace keywords in cp.cmd with values in user defined inputs and outputs::Dict{String} Simply evoke jp.main(inputs, outputs::Dict{String})\nReturned Outputs outputs provided in run(...) does not change outputs is overwritten by the returned value of jp.main\nDry Run Return (replaced_cmd::AbstractCmd, run_id_file::String) Return (fake_outputs::Dict{String}, run_id_file::String)","category":"page"},{"location":"julia_program/#Structure","page":"Julia Program","title":"Structure","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"JuliaProgram can be built with this method:","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"JuliaProgram <: Program\n\nJuliaProgram(;\n    name::String               = \"Unnamed Command Program\",\n    id_file::String            = \"\",\n    info_before::String        = \"auto\",\n    info_after::String         = \"auto\",\n    cmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n    inputs                     = Vector{String}(),\n    validate_inputs::Function  = do_nothing,  # positional arguments: inputs::Dict{String}\n    prerequisites::Function    = do_nothing,  # positional arguments: inputs, outputs::Dict{String}\n    main::Function             = do_nothing,  # positional arguments: inputs, outputs::Dict{String}\n    infer_outputs::Function    = do_nothing,  # positional arguments: inputs::Dict{String}\n    outputs                    = Vector{String}(),\n    validate_outputs::Function = do_nothing  # positional arguments: outputs::Dict{String},\n    wrap_up::Function          = do_nothing  # positional arguments: inputs, outputs::Dict{String}\n) -> JuliaProgram","category":"page"},{"location":"julia_program/#Run","page":"Julia Program","title":"Run","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"To run a JuliaProgram, the methods are the same as CmdProgram:","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"run(\n\tp::Program;\n\tinputs=Dict{String}(),\n\toutputs=Dict{String}(),\n\tdir::AbstractString=\"\",\n\tcheck_dependencies::Bool=true,\n\tskip_when_done::Bool=true,\n\ttouch_run_id_file::Bool=true,\n\tverbose=true,\n\tretry::Int=0,\n\tdry_run::Bool=false,\n\tstdout=nothing,\n\tstderr=nothing,\n\tstdlog=nothing,\n\tappend::Bool=false\n) -> (success::Bool, outputs::Dict{String})\n\nrun(p::Program, inputs, outputs; kwargs...)\n\nrun(p::Program, inputs; kwargs...)\n)  # only usable when `p.infer_outputs` is defined, or default outputs are set in `p`.","category":"page"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"note: Compatibility with JobSchedulers.jl\nPipelines.jl is fully compatible with JobSchedulers.jl which is a Julia-based job scheduler and workload manager inspired by Slurm and PBS.run(::Program, ...) can be replaced by Job(::Program, ...). The latter creates a Job, and you can submit the job to queue by using submit!(::Job). See example below.","category":"page"},{"location":"julia_program/#Example","page":"Julia Program","title":"Example","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"using Pipelines\n\np = JuliaProgram(\n    id_file = \"id_file\",\n    inputs = [\"a\", \"b\"],\n    outputs = [\"out\"],\n    main = (inputs, outputs) -> begin\n        a = inputs[\"a\"]\n        b = inputs[\"b\"]\n        println(\"inputs are \", a, \" and \", b)\n        println(\"You can also use info in outputs: \", outputs[\"out\"])\n\n        println(\"The returned value will be assigned to a new outputs\")\n        return Dict{String,Any}(\"out\" => b^2)\n    end\n)\n\ninputs = Dict(\n    \"a\" => `in1`,\n    \"b\" => 2\n)\n\noutputs = Dict(\n    \"out\" => \"will_be_replaced\"\n)\n\nsuccess, outputs = run(p, inputs, outputs;\n    touch_run_id_file = false\n) # outputs will be refreshed","category":"page"},{"location":"julia_program/#Compatibility-with-JobSchedulers.jl","page":"Julia Program","title":"Compatibility with JobSchedulers.jl","text":"","category":"section"},{"location":"julia_program/","page":"Julia Program","title":"Julia Program","text":"using JobSchedulers\n\nscheduler_start()  # start job scheduler\n\njob = Job(p, inputs, outputs;\n    touch_run_id_file = false\n)  # create a Job object; same arguments as `run`\n\nsubmit!(job)  # submit job to queue\n\nresult(job)  # get the returned result\n","category":"page"},{"location":"command_program/#Command-Program","page":"Command Program","title":"Command Program","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Please read the Quick Start section in Home page first.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Pipelines are built with multiple Programs. Program is the abstract type contains CmdProgram and JuliaProgram.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"A CmdProgram contains a command template, lists of dependencies/inputs/outputs, and predefined methods to prepare run-time environment, validate dependencies/inputs/outputs, and so on.","category":"page"},{"location":"command_program/#An-Example","page":"Command Program","title":"An Example","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We will go through an example to illustrate how to write a CmdProgram.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"The example is a robust Bowtie2 mapping program. It shows every functionality of CmdProgram, but in reality, we do not need that much validation.","category":"page"},{"location":"command_program/#Define-the-Name","page":"Command Program","title":"Define the Name","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    name = \"Bowtie2 Mapping\",# The name of CmdProgram\n    id_file = \".bowtie2\"     # When job completed, a file \".bowtie2.xxxxxx\" will\n                             # be created to indicate the job is finished to\n                             # avoid re-run.\n)","category":"page"},{"location":"command_program/#Main-Command-(Required)","page":"Command Program","title":"Main Command (Required)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"In Bash script, the main code of the example:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"REF=/path/to/reference_genome\nFASTQ=/path/to/input_fastq_file\nBAM=/path/to/output_bam_file\n\nbowtie2 -x $REF -q $FASTQ | samtools sort -O bam -o $BAM","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"The equivalent version using CmdProgram:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    inputs = [\n        \"FASTQ\" => String,\n        \"REF\" => \"human_genome_hg38.fa\" => String\n    ],\n    outputs = \"BAM\",\n    cmd = pipeline(`bowtie2 -x REF -q FASTQ`, `samtools sort -O bam -o BAM`)\n)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Now, the code can be run by invoking run(program_bowtie2, inputs, outputs), but to illustrate the full functionality, we will add more things to make it robust and easy to use.","category":"page"},{"location":"command_program/#Command-Dependency-(Robustness)","page":"Command Program","title":"Command Dependency (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We use samtools and bowtie2 as command dependencies. They can be wrapped in CmdDependency, which is illustrated in another page. Please allow me to skip it for now.","category":"page"},{"location":"command_program/#Infer-Outputs-(Convenience)","page":"Command Program","title":"Infer Outputs (Convenience↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We can set a default method to generate outputs::Dict{String} from inputs, which allows us run the program without specifying outputs (run(program_bowtie2, inputs).)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    outputs = \"BAM\",\n    infer_outputs = inputs -> begin\n        Dict(\"BAM\" => to_str(inputs[\"FASTQ\"]) * \".bam\")\n    end,\n    ...\n)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Or, the following does the same job:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    outputs = \"BAM\" => \"<FASTQ>.bam\" => String,\n    ...\n)","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"note: to_str(x) and to_cmd(x)\nto_str converts most types to String, and to_cmd to Cmd. They are tailored for parsing inputs[\"x\"] and outputs[\"x\"].User-defined inputs, outputs::Dict{String} only confine the key type (String), does not confine the value type because of flexibility. When writing functions using inputs/outputs, we should consider this. It can be a Number, a Cmd, a String, and even a Vector. Pipeline.jl provides to_str and to_cmd to elegantly convert those types to String or Cmd as you wish.Other conversions are also available, such as replaceext (replace extension) and removeext (remove extension). More details are in API/Utils page.","category":"page"},{"location":"command_program/#Validate-Inputs-(Robustness)","page":"Command Program","title":"Validate Inputs (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"To make the code robust, we can check whether the inputs exists by using validate_inputs. It is a function takes inputs::Dict{String} as the argument.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    inputs = [\n        \"FASTQ\" => String,\n        \"REF\" => \"human_genome_hg38.fa\" => String\n    ],\n    validate_inputs = inputs -> begin\n        check_dependency_file(inputs[\"FASTQ\"]) &&\n        check_dependency_file(inputs[\"REF\"])\n    end,\n    ...\n)","category":"page"},{"location":"command_program/#Prerequisites-(Robustness)","page":"Command Program","title":"Prerequisites (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"We also need to prepare something (prerequisites) before running the main command. For example, create the output directory if not exist. (prerequisites) is a function takes inputs::Dict{String}, outputs::Dict{String} as the arguments.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    prerequisites = (inputs, outputs) -> begin\n        mkpath(dirname(to_str(outputs[\"BAM\"])))\n    end\n)","category":"page"},{"location":"command_program/#Validate-Outputs-(Robustness)","page":"Command Program","title":"Validate Outputs (Robustness↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"After running the main command, we can validate outputs by using validate_outputs. It is a function takes outputs::Dict{String} as the argument.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    outputs = \"BAM\",\n    validate_outputs = outputs -> begin\n        check_dependency_file(outputs[\"BAM\"])\n    end,\n    ...\n)","category":"page"},{"location":"command_program/#Wrap-Up-(Convenience)","page":"Command Program","title":"Wrap Up (Convenience↑)","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"After validating outputs, we may also do something to wrap up, such as removing temporary files. Here, we build an index for output BAM file. wrap_up function takes inputs::Dict{String}, outputs::Dict{String} as the arguments.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    ...,\n    wrap_up = (inputs, outputs) -> run(`samtools index $(outputs[\"BAM\"])`)\n)","category":"page"},{"location":"command_program/#The-Final-Code","page":"Command Program","title":"The Final Code","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"All in all, the final program is like this:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"program_bowtie2 = CmdProgram(\n    name = \"Bowtie2 Mapping\",\n    id_file = \".bowtie2\",\n\n    inputs = [\n        \"FASTQ\" => String,\n        \"REF\" => \"human_genome_hg38.fa\" => String\n    ],\n    validate_inputs = inputs -> begin\n        check_dependency_file(inputs[\"FASTQ\"]) &&\n        check_dependency_file(inputs[\"REF\"])\n    end,\n\n    prerequisites = (inputs, outputs) -> begin\n        mkpath(dirname(to_str(outputs[\"BAM\"])))\n    end,\n\n    outputs = [\"BAM\"],\n    infer_outputs = inputs -> begin\n        Dict(\"BAM\" => str(inputs[\"FASTQ\"]) * \".bam\")\n    end,\n    validate_outputs = outputs -> begin\n        check_dependency_file(outputs[\"BAM\"])\n    end,\n\n    cmd = pipeline(`bowtie2 -x REF -q FASTQ`, `samtools sort -O bam -o BAM`),\n\n    wrap_up = (inputs, outputs) -> run(`samtools index $(outputs[\"BAM\"])`)\n)","category":"page"},{"location":"command_program/#Structure","page":"Command Program","title":"Structure","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"CmdProgram can be built with this method:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"CmdProgram <: Program\n\nCmdProgram(;\n\tname::String               = \"Command Program\",\n\tid_file::String            = \"\",\n\tinfo_before::String        = \"auto\",\n\tinfo_after::String         = \"auto\",\n\tcmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n\tinputs                     = Vector{String}(),\n\tvalidate_inputs::Function  = do_nothing,  # positional arguments: inputs::Dict{String, ValidInputTypes}\n\tprerequisites::Function    = do_nothing,  # positional arguments: inputs, outputs::Dict{String, ValidInputTypes}\n\tcmd::Base.AbstractCmd      = ``,\n\tinfer_outputs::Function    = do_nothing,  # positional arguments: inputs::Dict{String, ValidInputTypes}\n\toutputs                    = Vector{String}(),\n\tvalidate_outputs::Function = do_nothing  # positional arguments: outputs::Dict{String, ValidInputTypes},\n\twrap_up::Function          = do_nothing  # positional arguments: inputs, outputs::Dict{String, ValidInputTypes}\n) -> CmdProgram","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"In this way, all preparation and post-evaluation can be wrapped in a single CmdProgram. It is easy to maintain and use.","category":"page"},{"location":"command_program/#Run","page":"Command Program","title":"Run","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"To run a Program, use one of the following methods:","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"run(\n\tp::Program;\n\tinputs=Dict{String}(),\n\toutputs=Dict{String}(),\n\tdir::AbstractString=\"\",\n\tcheck_dependencies::Bool=true,\n\tskip_when_done::Bool=true,\n\ttouch_run_id_file::Bool=true,\n\tverbose=true,\n\tretry::Int=0,\n\tdry_run::Bool=false,\n\tstdout=nothing,\n\tstderr=nothing,\n\tstdlog=nothing,\n\tappend::Bool=false\n) -> (success::Bool, outputs::Dict{String})\n\nrun(p::Program, inputs, outputs; kwargs...)\n\nrun(p::Program, inputs; kwargs...)\n)  # only usable when outputs have default values.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"note: Note\nRedirecting and directory change in Julia are not thread safe, so unexpected redirection and directory change might be happen if you are running programs in different Tasks or multi-thread mode.","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"note: Compatibility with JobSchedulers.jl\nPipelines.jl is fully compatible with JobSchedulers.jl which is a Julia-based job scheduler and workload manager inspired by Slurm and PBS.run(::Program, ...) can be replaced by Job(::Program, ...). The latter creates a Job, and you can submit the job to queue by using submit!(::Job).","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"The explanation of arguments is in the next section.","category":"page"},{"location":"command_program/#Workflow","page":"Command Program","title":"Workflow","text":"","category":"section"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"Go to the working directory. Establish redirection. (dir, stdout, stderr, stdlog, append).\nCheck keywords consistency: Inputs/outputs keywords should be consistent in both p::CmdProgram and run(p; inputs, outputs).\nFor example, if inputs and outputs in p::CmdProgram is defined this wayp = CmdProgram(..., inputs = [\"I\", \"J\"], outputs = [\"K\"])The inputs and outputs in run(...) has to berun(p;\n    inputs = Dict(\n        \"I\" => something,\n        \"J\" => something\n    ),\n    outputs = Dict(\"K\" => something)\n)\nPrint info about starting program.\nThe content can set by p.info_before::String.Disable: run(..., verbose=false)\nCheck whether the program ran successfully before. If so, return (true, outputs::Dict{String}) without running it.\nHow does the program know it ran before?a. run(..., skip_when_down=true) enables the functionality.b. Run id file is generated. The prefix of run id file is set by p.id_file. After given inputs and outputs, a unique ID will be appended to the prefix. You can use run(..., touch_run_id_file=false) to skip creating the run id file.c. p.validate_outputs(outputs) run successfully without returning false.\nCheck command dependencies (CmdDependency).\nDisable: run(..., check_dependencies=false)Read Command Dependency portion for details.\nRemove the run id file if exists.\nValidate inputs by invoking p.validate_inputs(inputs).\nPreparing the main command.\nIf you specify run(...; stdout=something, stderr=something, append::Bool), the command (cmd) will be wrapped with pipeline(cmd; stdout=something, stderr=something, append::Bool). If cmd has its own file redirection, the outer wrapper may not work as you expect.\nMeet prerequisites by invoking p.prerequisites(inputs, outputs).\nIt is the last function before running the main command.  For example, you can create a directory if  the main command cannot create itself.\nRun the main command.\nValidate outputs by invoking p.validate_outputs(outputs).\nRun the wrap up function by invoking p.wrap_up(inputs, outputs)\nIt is the last function to do after-command jobs. For example, you can delete intermediate files if necessary.\nCreate run id file if run(..., touch_run_id_file=true). Read Step 3 for details.\nPrint info about finishing program.\nThe content can set by p.info_after::String.Disable: run(..., verbose=false)\nReturn (success::Bool, outputs{String})","category":"page"},{"location":"command_program/","page":"Command Program","title":"Command Program","text":"note: Dry Run\nrun(..., dry_run=true) will return (mature_command::AbstractCmd, run_id_file::String) instead.","category":"page"},{"location":"changelog/#Change-log","page":"Change Log","title":"Change log","text":"","category":"section"},{"location":"changelog/#v0.7.3","page":"Change Log","title":"v0.7.3","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix a method overwrite warning when defining Base.redirect_stdout(f::Function, ::Nothing) = f(): redirectstdout and redirectstderr are the same (::Base.RedirectStdStream) at least from julia v1.7, so defining redirectstdout means redirectstderr is also defined. If diff exists in previous julia versions, check first.","category":"page"},{"location":"changelog/#v0.7.2","page":"Change Log","title":"v0.7.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: do not show the error stack traces twice (@error and rethrow()).","category":"page"},{"location":"changelog/#v0.7.1","page":"Change Log","title":"v0.7.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: the returned value of the main function of JuliaProgram does not required to be a Dict. If it is not a Dict or the returned Dict fails to pass keyword check, a warn message will be displayed and the inferred outputs will be used.\nFix: MethodError: no method matching sort(::Dict{String, Any}) in generate_run_uuid(...): import OrderedCollections.jl.\nOptimize: do not show the error messages twice when stderr is not redirected.","category":"page"},{"location":"changelog/#v0.7.0","page":"Change Log","title":"v0.7.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: generate_run_uuid: more stable way to generate run UUID using inputs and outputs.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Caution: The UUIDs generated using old versions will be out of date, so if you run the same Program with the same parameters, the program will generate a different UUID. This is why it is considered as a breaking version.","category":"page"},{"location":"changelog/#v0.6.1","page":"Change Log","title":"v0.6.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: to_xxput_dict(d::Dict): v not defined: change v to d.\nFix: xxputs_completion_and_check(p, inputs, outputs): Now, if outputs are not empty and p.infer_outputs is defined, the function will first run p.infer_outputs and then merge the result and outputs (user-input keys are kept).\nOptimize: function infer_outputs(p::Program, inputs) now works like xxputs_completion_and_check but only return outputs::Dict{String}. It does not affect user-defined function p.infer_outputs. In addition, inputs is no longer strict to Dict{String} because the it will convert to Dict{String} first.","category":"page"},{"location":"changelog/#v0.6.0","page":"Change Log","title":"v0.6.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: allow retry for failed program: run(p::Program, ...; retry = 1).\nFix: the run id file generated after a successful run is under the directory specified in run(p::Program, ...; dir = \"directory\"), if p.id_file is not an absolute path (default).\nFeature: verbose in run(p::Program, ...; verbose = :min): If true or :all, print all info and error messages. If :min, print minimum info and error messages. If false or :none, print error messages only.","category":"page"},{"location":"changelog/#v0.5.2","page":"Change Log","title":"v0.5.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: Export restore_stderr.","category":"page"},{"location":"changelog/#v0.5.1","page":"Change Log","title":"v0.5.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: stdxxx_origin set to nothing when reloading Pipelines from another module.","category":"page"},{"location":"changelog/#v0.5.0","page":"Change Log","title":"v0.5.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: stack traces of failed results.\nFix: original stdout and stderr can be recovered by using restore_stdout() and restore_stderr(). Remove set_default_stdout() and set_default_stderr() because they cause confusion sometimes.\nOptimize: default output of program info.","category":"page"},{"location":"changelog/#v0.4.6","page":"Change Log","title":"v0.4.6","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: results of isok(::AbstractString) should be expected.","category":"page"},{"location":"changelog/#v0.4.5","page":"Change Log","title":"v0.4.5","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: allow check dependencies when test argument is empty.","category":"page"},{"location":"changelog/#.4.4","page":"Change Log","title":"0.4.4","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: change DataType to Type throughout the code. It allows successful parsing of Union Type, such as \"READ1\" => Union{String, Vector{String}}.","category":"page"},{"location":"changelog/#v0.4.3","page":"Change Log","title":"v0.4.3","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix file redirecting exception when redirecting to a closed stream. Not solved: Redirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.","category":"page"},{"location":"changelog/#v0.4.2","page":"Change Log","title":"v0.4.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Better error stack trace after capturing.\nUpdate file redirecting.","category":"page"},{"location":"changelog/#v0.4.1","page":"Change Log","title":"v0.4.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix file redirecting.","category":"page"},{"location":"changelog/#v0.4.0","page":"Change Log","title":"v0.4.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: run(p::Program, ...) supports running at a specified directory (dir). Run ID files will also create at that directory.\nFeature: run(p::Program, ...) supports redirecting stdout, stderr and stdlog (Julia log output, such as @info, @warn, @error).\nFix: CmdProgram supports commands such as pipeline(cmd, stdout=stderr), which redirect stdout to stderr now because prepare_cmd(h::Base.TTY, inputs, outputs) method is added.","category":"page"},{"location":"changelog/#v0.3.2","page":"Change Log","title":"v0.3.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: CmdDependency: do not check when test_args are empty.","category":"page"},{"location":"changelog/#v0.3.1","page":"Change Log","title":"v0.3.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: to_cmd and to_str: support argument ::Regex or ::Any.","category":"page"},{"location":"changelog/#v0.3.0","page":"Change Log","title":"v0.3.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Building Program: Support type assertion and default arguments of inputs and outputs, such as \"arg\" => 5, \"arg\" => Int, \"arg\" => 5 => Int, \"arg\" => Int => 5.\nFeature: Program and run(::Program) no longer require inputs and outputs to be Vector or Dict. They can be both Vector or Dict, or even an element of Vector or Dict, as long as they can be converted. Eg:\np = CmdProgram(\n    cmd_dependencies = [julia],\n    id_file = \"id_file\",\n    inputs = [\n        \"input\",\n        \"input2\" => Int,\n        \"optional_arg\" => 5,\n        \"optional_arg2\" => 0.5 => Number\n    ],\n    outputs = \"output\" => \"<input>.output\"\n    ,\n    cmd = `echo input input2 optional_arg optional_arg2 output`\n)\n\ninputs = Dict(\n    \"input\" => `in1`,\n    \"input2\" => 2\n)\n\noutputs = [\n    \"output\" => \"out\"\n]\n\nrun(p, inputs, outputs,\n    skip_when_done = false,\n    verbose = true,\n    touch_run_id_file = false\n)\nFeature: Pretty print of Program. Eg:\njulia> p\nCmdProgram:\n  name             → Command Program\n  id_file          → id_file\n  info_before      → auto\n  info_after       → auto\n  cmd_dependencies → CmdDependency[`/usr/software/julia-1.4.2/bin/julia -Cnative -J/usr/software/julia-1.4.2/lib/julia/sys.so -O3 -g1`]\n  inputs           → \"input\"         :: Any    (required)\n                     \"input2\"        :: Int64  (required)\n                     \"optional_arg\"  :: Any    (default: 5)\n                     \"optional_arg2\" :: Number (default: 0.5)\n  validate_inputs  → do_nothing\n  prerequisites    → do_nothing\n  cmd              → `echo input input2 optional_arg optional_arg2 output`\n  infer_outputs    → do_nothing\n  outputs          → \"output\" :: Any (default: <input>.output)\n  validate_outputs → do_nothing\n  wrap_up          → do_nothing","category":"page"},{"location":"changelog/#v0.2.2","page":"Change Log","title":"v0.2.2","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Support JobSchedulers.jl.","category":"page"},{"location":"changelog/#v0.2.1","page":"Change Log","title":"v0.2.1","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix examples in docs.","category":"page"},{"location":"changelog/#v0.2.0","page":"Change Log","title":"v0.2.0","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"CmdDependency: Better interpolation in Cmd.\ndep::CmdDepencendy\n\n# old version\n`$(dep.exec) --args`\n# or\n`$(exec(dep)) --args`\n\n# now\n`$dep --args`\nNew JuliaProgram for pure Julia implementation.\nProgram is the Abstract type containing CmdProgram and JuliaProgram substypes.","category":"page"},{"location":"#Pipelines.jl","page":"Home","title":"Pipelines.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Pipelines","category":"page"},{"location":"","page":"Home","title":"Home","text":"A lightweight Julia package for computational pipelines.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building reusable pipelines and workflows is easier than you have ever thought.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy to build both simple and complex tasks.\nSupports external command lines and pure Julia functions.\nSupports resuming interrupted tasks, skipping finished tasks.\nSupports dependency check.\nSupports inputs, outputs validation, and so on.\nSupports program queuing and workload management with JobSchedulers.jl","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Pipelines","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pipelines","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines are built with multiple Programs. Program is the abstract type of CmdProgram and JuliaProgram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A CmdProgram contains a command template and name lists of inputs/outputs. The names of inputs/outputs will be replaced by real values when executing the program.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's set up a simple CmdProgram to print values using echo:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pipelines\n\necho = CmdProgram(\n    inputs = [\n        \"REQUIRED\",               # no default value; any data type.\n        \"TYPED\" => String,        # no default value; String type only.\n        \"OPTIONAL\" => 4,          # default value is 4; any data type.\n        \"FULL\" => String => \"abc\" # default value is abc; String type only.\n    ],\n    cmd = `echo REQUIRED TYPED OPTIONAL FULL`   \n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Running the program is just like running other Cmd,  but here we need to specify inputs by using Dict{String => value} (Vector{String => value} is also supported.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"inputs = Dict(\n    \"REQUIRED\" => \"Pipelines.jl\",\n    \"TYPED\" => \"is\",\n    \"FULL\" => \"everyone!\"\n)\nrun(echo, inputs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Program will not run twice by default!\nIf you run a program with the same inputs again, the program will just return the same result, display a warning message without running the command twice.run(echo, inputs)This is because the program will generate a file (run id file) in the current directory indicating the program has been run. Several methods can be used to re-run a program:# Method 1: stop checking finished program\nrun(echo, inputs; skip_when_done = false)\n\n# Method 2: delete the run_id_file before running again:\ncmd, run_id_file = run(echo, inputs; dry_run = true) # Dry-run returns the command and run id file without running it.\nrm(run_id_file)  # remove the run_id_file\n\n# Method 3: Do not generate run_id_file when first running.\nrun(echo, inputs; touch_run_id_file=false)","category":"page"},{"location":"#Program-with-Outputs","page":"Home","title":"Program with Outputs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unlike the first example, many programs write files as outputs. Pipelines.jl has an elegant way to handle it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following program prints values simultaneously, sort them, and save to a file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prog = CmdProgram(\n    inputs = [\"INPUT1\", \"INPUT2\", \"INPUT3\"],\n    outputs = \"OUTPUT_FILE\",\n    cmd = pipeline(`echo INPUT1 INPUT2` & `echo INPUT3`, `sort`, \"OUTPUT_FILE\")\n)\n\ninputs = Dict(\n    \"INPUT1\" => \"Hello,\",\n    \"INPUT2\" => `Pipeline.jl`,\n    \"INPUT3\" => 39871\n)\noutputs = \"OUTPUT_FILE\" => \"out.txt\" # save output to file\n\nrun(prog, inputs, outputs) # will return (success::Bool, outputs)\n\nrun(`cat out.txt`) # print the content of out.txt\n# 39871\n# Hello, Pipeline.jl","category":"page"},{"location":"#Default-values","page":"Home","title":"Default values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Default values and data types can be set for keywords of inputs and outputs in this way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"echo = CmdProgram(\n    inputs = [\n        \"REQUIRED\",                     # no default value; any data type.\n        \"TYPED\" => String,              # no default value; String type only.\n        \"OPTIONAL\" => 4,                # default value is 5; any data type.\n        \"FULL1\" => String => \"abc\"      # default value is abc; String type only.\n        \"FULL2\" => \"abc\" => String      # default value is abc; String type only.\n        \"INTERPOLATED\" => \"<FULL1>.xyz\" # default value is value of FULL1 * \".xyz\".\n    ],\n    cmd = `echo REQUIRED TYPED OPTIONAL FULL`   \n)","category":"page"},{"location":"#Interpolation-of-default-values","page":"Home","title":"Interpolation of default values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the default value is a String, it can be interpolated by using <keyword>, such as \"<FULL1>.xyz\" in the example.","category":"page"},{"location":"#Generate-outputs-using-Function","page":"Home","title":"Generate outputs using Function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This step is prior to adding default values of outputs, and string interpolation using <>.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We also provide a parameter (infer_outputs::Function) in CmdProgram to generate complex outputs::Dict{String} from inputs::Dict{String}. The argument (inputs) and returned value of the function has to be a Dict{String}.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates\n\nprog = CmdProgram(\n    inputs = [\n        \"INPUT1\" => Int,\n        \"INPUT2\" => Int => 3\n    ],\n    outputs = \"OUTPUT_FILE\",\n    cmd = pipeline(`echo INPUT1 INPUT2`, `sort`, \"OUTPUT_FILE\"),\n    infer_outputs = inputs -> Dict(\n        \"OUTPUT_FILE\" => string(now(), \"__\", inputs[\"INPUT1\"], \".txt\")\n    )\n)\nsuccess, outputs = run(prog, \"INPUT1\" => 5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also generate default outputs without running the program:","category":"page"},{"location":"","page":"Home","title":"Home","text":"outputs = infer_outputs(prog, inputs)","category":"page"},{"location":"#Julia-Program","page":"Home","title":"Julia Program","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines also defined JuliaProgram type for pure Julia functions. It is like CmdProgram and remain most compatibility. More details are in the Julia Program, Manual Page.","category":"page"},{"location":"#Compatibility-with-JobSchedulers.jl","page":"Home","title":"Compatibility with JobSchedulers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pipelines.jl is fully compatible with JobSchedulers.jl which is a Julia-based job scheduler and workload manager inspired by Slurm and PBS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"run(::Program, ...) can be replaced by Job(::Program, ...). The latter creates a Job, and you can submit the job to queue by using submit!(::Job).","category":"page"},{"location":"#Future-Development","page":"Home","title":"Future Development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support running competitive tasks with locks.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Program","page":"API","title":"Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Program","category":"page"},{"location":"API/#Pipelines.Program","page":"API","title":"Pipelines.Program","text":"Summary\n\nabstract type Program <: Any\n\nSubtypes\n\nCmdProgram\nJuliaProgram\n\n\n\n\n\n","category":"type"},{"location":"API/#Command-Program","page":"API","title":"Command Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CmdProgram()\nprepare_cmd","category":"page"},{"location":"API/#Pipelines.CmdProgram-Tuple{}","page":"API","title":"Pipelines.CmdProgram","text":"CmdProgram <: Program\n\nCmdProgram(;\n\tname::String               = \"Command Program\",\n\tid_file::String            = \"\",\n\tinfo_before::String        = \"auto\",\n\tinfo_after::String         = \"auto\",\n\tcmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n\tinputs                     = Vector{String}(),\n\tvalidate_inputs::Function  = do_nothing,  # positional arguments: inputs::Dict{String, ValidInputTypes}\n\tprerequisites::Function    = do_nothing,  # positional arguments: inputs, outputs::Dict{String, ValidInputTypes}\n\tcmd::Base.AbstractCmd      = ``,\n\tinfer_outputs::Function    = do_nothing,  # positional arguments: inputs::Dict{String, ValidInputTypes}\n\toutputs                    = Vector{String}(),\n\tvalidate_outputs::Function = do_nothing  # positional arguments: outputs::Dict{String, ValidInputTypes},\n\twrap_up::Function          = do_nothing  # positional arguments: inputs, outputs::Dict{String, ValidInputTypes}\n) -> CmdProgram\n\nCommand program template. To run a CmdProgram, use run(::CmdProgram; kwargs...).\n\nArguments\n\nname::String: Program name.\nid_file::String: The prefix of run ID file. To prevent from running the program with the same inputs and outputs twice, it will generate a unique run ID file after a successful run.\ninfo_before::String: Print it when the program is started.\ninfo_after::String: Print it when the program is finished.\ncmd_dependencies::Vector{CmdDependency}: Any command dependencies used in the program.\ninputs and outputs: Elements (or vectors containing elements) in the following format: (1) keyword (2) keyword => data_type (3) keyword => default_value (4) keyword => default_value => data_type.\nkeyword is an argument name, can be String or Symbol.\ndefault_value is optional. If set, users may not provide this argument when running. Elsewise, users have to provide it. Caution: nothing is preserved and means default value not set. If String, it can contain other keywords, but need to quote using '<>', such as \"<arg>.txt\"\ndata_type is optional. If set, the value provided have to be this data type, or an error will throw.\nHOW DOES THIS WORK?\nCmdProgram stores a command template. In the template, replaceable portions are occupied by keywords, and all keywords are set in inputs and outputs. keywords will be replaced before running the program. Users need to provide a dictionary of keyword::String => value in run(::Program, inputs::Dict{String}, outputs::Dict{String}).\nvalidate_inputs::Function: A function to validate inputs. It takes one argument Dict{String, ValidInputTypes} whose keys are the same as inputs. If validation fail, throw error or return false.\nprerequisites: A function to run just before the main command. It prepares necessary things, such as creating directories. It takes two arguments Dict{String, ValidInputTypes} whose keys are the same as inputs and outputs, respectively.\ncmd::AbstractCmd: The main command template. In the template, keywords in inputs::Vector{String} and outputs::Vector{String} will be replaced when envoking run(::CmdProgram, inputs::Dict{String, ValidInputTypes}, outputs::Dict{String, ValidInputTypes}).\ninfer_outputs::Function: A function to infer outputs from inputs. It takes one argument Dict{String, ValidInputTypes} whose keys are the same as inputs.\nvalidate_outputs::Function: A function to validate outputs. It takes one argument Dict{String, ValidInputTypes} whose keys are the same as outputs. If validation fail, throw error or return false.\nwrap_up::Function: the last function to run. It takes two arguments Dict{String, ValidInputTypes} whose keys are the same as inputs and outputs, respectively.\n\nExample\n\np = CmdProgram(\n\tid_file = \"id_file\",\n\tinputs = [\n\t\t\"input\",\n\t\t\"input2\" => Int,\n\t\t\"optional_arg\" => 5,\n\t\t\"optional_arg2\" => 0.5 => Number\n\t],\n\toutputs =\n\t\t\"output\" => \"<input>.output\"\n\t,\n\tcmd = `echo input input2 optional_arg optional_arg2 output`\n)\n\ninputs = Dict(\n\t\"input\" => `in1`,\n\t\"input2\" => 2\n)\n\noutputs = Dict(\n\t\"output\" => \"out\"\n)\n\nrun(p, inputs, outputs;\n\ttouch_run_id_file = false\n)\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.prepare_cmd","page":"API","title":"Pipelines.prepare_cmd","text":"prepare_cmd(p::CmdProgram, inputs, outputs)\n\nPrepare the runable command. Keywords in CmdProgram will be given to values of inputs/outputs.\n\n\n\n\n\n","category":"function"},{"location":"API/#Julia-Program","page":"API","title":"Julia Program","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"JuliaProgram()","category":"page"},{"location":"API/#Pipelines.JuliaProgram-Tuple{}","page":"API","title":"Pipelines.JuliaProgram","text":"JuliaProgram <: Program\n\nJuliaProgram(;\n\tname::String               = \"Unnamed Command Program\",\n\tid_file::String            = \"\",\n\tinfo_before::String        = \"auto\",\n\tinfo_after::String         = \"auto\",\n\tcmd_dependencies::Vector{CmdDependency} = Vector{CmdDependency}(),\n\tinputs                     = Vector{String}(),\n\tvalidate_inputs::Function  = do_nothing,  # positional arguments: inputs::Dict{String}\n\tprerequisites::Function    = do_nothing,  # positional arguments: inputs, outputs::Dict{String}\n\tmain::Function             = do_nothing,  # positional arguments: inputs, outputs::Dict{String}\n\tinfer_outputs::Function    = do_nothing,  # positional arguments: inputs::Dict{String}\n\toutputs                    = Vector{String}(),\n\tvalidate_outputs::Function = do_nothing,  # positional arguments: outputs::Dict{String}\n\twrap_up::Function          = do_nothing  # positional arguments: inputs, outputs::Dict{String}\n) -> JuliaProgram\n\nJulia program template. To run a JuliaProgram, use run(::JuliaProgram; kwargs...).\n\nArguments\n\nname::String: Program name.\nid_file::String: The prefix of run ID file. To prevent from running the program with the same inputs and outputs twice, it will generate a unique run ID file after a successful run.\ninfo_before::String: Print it when the program is started.\ninfo_after::String: Print it when the program is finished.\ncmd_dependencies::Vector{CmdDependency}: Any command dependencies used in the program.\ninputs and outputs: Elements (or vectors containing elements) in the following format: (1) keyword (2) keyword => data_type (3) keyword => default_value (4) keyword => default_value => data_type.\nkeyword is an argument name, can be String or Symbol.\ndefault_value is optional. If set, users may not provide this argument when running. Elsewise, users have to provide it. Caution: nothing is preserved and means default value not set. If String, it can contain other keywords, but need to quote using '<>', such as \"<arg>.txt\"\ndata_type is optional. If set, the value provided have to be this data type, or an error will throw.\nHOW DOES THIS WORK?\nJuliaProgram stores a Julia function, with two arguments inputs::Dict{String}, outputs::Dict{String}. The keys of the two arguments should be set in inputs::Vector{String} and outputs::Vector{String}. Caution: the returned value of p.main will be assigned to new outputs. Please ensure the returned value is Dict{String} with proper keys.\nvalidate_inputs::Function: A function to validate inputs. It takes one argument Dict{String} whose keys are the same as inputs. If validation fail, throw error or return false.\nprerequisites: A function to run just before the main command. It prepares necessary things, such as creating directories. It takes two arguments Dict{String} whose keys are the same as inputs and outputs, respectively.\nmain::Function: The main julia function. It takes two arguments Dict{String} whose keys are the same as inputs and outputs, respectively.\nCaution: the returned value of p.main will be assigned to new outputs. Please ensure the returned value is Dict{String} with proper keys.\ninfer_outputs::Function: A function to infer outputs from inputs. It takes one argument Dict{String} whose keys are the same as inputs.\nvalidate_outputs::Function: A function to validate outputs. It takes one argument Dict{String} whose keys are the same as outputs. If validation fail, throw error or return false.\nwrap_up::Function: the last function to run. It takes two arguments Dict{String} whose keys are the same as inputs and outputs, respectively.\n\nExample\n\np = JuliaProgram(\n\tid_file = \"id_file\",\n\tinputs = [\n\t\t\"a\",\n\t\t\"b\" => Int\n\t],\n\toutputs =\n\t\t\"c\" => \"<a>.<b>\"\n\t,\n\tmain = (inputs, outputs) -> begin\n\t\ta = inputs[\"a\"]\n\t\tb = inputs[\"b\"]\n\t\tprintln(\"inputs are \", a, \" and \", b)\n\t\tprintln(\"You can also use info in outputs: \", outputs[\"c\"])\n        println(\"The returned value will be assigned to a new outputs\")\n\n        return Dict{String,Any}(\"c\" => b^2)\n\tend\n)\n\ninputs = Dict(\n\t\"a\" => `in1`,\n\t\"b\" => 2\n)\n\noutputs = Dict(\n\t\"c\" => \"out\"\n)\n\nsuccess, outputs = run(p, inputs, outputs;\n\ttouch_run_id_file = false\n) # outputs will be refreshed\n\n\n\n\n\n","category":"method"},{"location":"API/#Run-Programs","page":"API","title":"Run Programs","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Base.run","category":"page"},{"location":"API/#Base.run","page":"API","title":"Base.run","text":"run(\n\tp::CmdProgram;\n\tinputs=Dict{String}(),\n\toutputs=Dict{String}(),\n\tdir::AbstractString=\"\",\n\tcheck_dependencies::Bool=true,\n\tskip_when_done::Bool=true,\n\ttouch_run_id_file::Bool=true,\n\tverbose=true,\n\tretry::Int=0,\n\tdry_run::Bool=false,\n\tstdout=nothing,\n\tstderr=nothing,\n\tstdlog=nothing,\n\tappend::Bool=false\n) -> (success::Bool, outputs::Dict{String})\n\nrun(p::CmdProgram, inputs, outputs; kwargs...)\n\nrun(p::CmdProgram, inputs; kwargs...)\n)  # only usable when `p.infer_outputs` is defined, or default outputs are set in `p`.\n\nRun Command Program (CmdProgram) using specified inputs and outputs.\n\nReturn (success::Bool, outputs::Dict{String})\n\np::CmdProgram: the command program template.\ninputs::Dict{String} and outputs::Dict{String}: p::CmdProgram stores a command template. In the template, replaceable portions are occupied by keywords, and all keywords can be found at p.inputs and p.outputs string vectors. Here, inputs and outputs are Dict(keyword::String => replacement). The replacements do not have a length limit, unless a keyword refers to a filename (length == 1).\nIf data types of inputs and outputs are not Dict{String}, they will be converted as far as possible. If the conversion fails, program will throw an error.\ndir::AbstractString = \"\": working directory to run the program and store run_id_file.\ncheck_dependencies::Bool = true: check dependencies for p (p.cmd_dependencies).\nskip_when_done::Bool = true: Skip running the program and return true if it has been done before (the run_id_file exists and p.validate_outputs(outputs) passes.)\ntouch_run_id_file::Bool = true: If true, touch a unique run ID file, which indicate the program is successfully run with given inputs and outputs. If false, the next time running the program, skip_when_done=true will not take effect.\nverbose = true: If true or :all, print all info and error messages. If :min, print minimum info and error messages. If false or :none, print error messages only.\nretry::Int = 0: If failed, retry for INT times.\ndry_run::Bool = false: do not run the command, return (command::AbstractCmd, run_id_file::String).\nstdout, stderr, stdlog and append: Redirect the program outputs to files. stdlog is the Julia logging of @info, @warn, @error, etc. Caution: If the original command (p.cmd) has redirection, arguments defined here might not be effective for the command.\n\nnote: Note\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.\n\nWorkflow\n\nGo to the working directory. Establish redirection. (dir, stdout, stderr, stdlog, append).\nValidate compatibility between p and inputs/outputs.\nCheck whether the program has run before. (skip_when_done, p.validate_outputs(outputs))\nCheck command dependencies. (check_dependencies, p.cmd_dependencies)\nValidate inputs. (p.validate_inputs(inputs))\nGenerate runnable command from p and inputs/outputs. (stdout, stderr, append)\nPreparing before running main command. (p.prerequisites(inputs, outputs))\nRun command generated in #5.\nValidate outputs. (p.validate_outputs(outputs))\nWrap up. (p.wrap_up(inputs, outputs))\nSuccess, touch run id file, and return (success::Bool, outputs::Dict{String}). (touch_run_id_file::Bool)\n\nExample\n\np = CmdProgram(\n\tid_file = \"id_file\",\n\tinputs = [\"input\", \"input2\"],\n\toutputs = [\"output\"],\n\tcmd = `echo input input2 output`\n)\n\ninputs = Dict(\n\t\"input\" => `in1`,\n\t\"input2\" => 2\n)\n\noutputs = Dict(\n\t\"output\" => \"out\"\n)\n\nrun(p, inputs, outputs;\n\ttouch_run_id_file = false\n)\n\n\n\n\n\n\n\nrun(\n\tp::JuliaProgram;\n\tinputs=Dict{String}(),\n\toutputs=Dict{String}(),\n\tdir::AbstractString=\"\",\n\tcheck_dependencies::Bool=true,\n\tskip_when_done::Bool=true,\n\ttouch_run_id_file::Bool=true,\n\tverbose=true,\n\tretry::Int=0,\n\tdry_run::Bool=false,\n\tstdout=nothing,\n\tstderr=nothing,\n\tstdlog=nothing,\n\tappend::Bool=false\n) -> (success::Bool, outputs::Dict{String})\n\nrun(p::JuliaProgram, inputs, outputs; kwargs...)\n\nrun(p::JuliaProgram, inputs; kwargs...)\n)  # only usable when `p.infer_outputs` is defined, or default outputs are set in `p`.\n\nRun Julia Program (JuliaProgram) using specified inputs and outputs.\n\nReturn (success::Bool, outputs::Dict{String})\n\np::JuliaProgram: the command program template.\ninputs::Dict{String} and outputs::Dict{String}: JuliaProgram stores a Julia function, with two arguments inputs::Dict{String}, outputs::Dict{String}. The keys of the two arguments should be the same as p.inputs::Vector{String} and p.outputs::Vector{String}.\nIf data types of inputs and outputs are not Dict{String}, they will be converted as far as possible. If the conversion fails, program will throw an error. Caution: the returned value of p.main will be assigned to new outputs. Please ensure the returned value of p.main is Dict{String} with proper keys.\ndir::AbstractString = \"\": working directory to run the program and store run_id_file.\ncheck_dependencies::Bool = true: check dependencies for p (p.cmd_dependencies).\nskip_when_done::Bool = true: Skip running the program and return true if it has been done before (the run_id_file exists and p.validate_outputs(outputs) passes.)\ntouch_run_id_file::Bool = true: If true, touch a unique run ID file, which indicate the program is successfully run with given inputs and outputs. If false, the next time running the program, skip_when_done=true will not take effect.\nverbose = true: If true or :all, print all info and error messages. If :min, print minimum info and error messages. If false or :none, print error messages only.\nretry::Int = 0: If failed, retry for INT times.\ndry_run::Bool = false: do not run the command, return (fake_outputs::Dict{String}, run_id_file::String).\nstdout, stderr, stdlog and append: Redirect the program outputs to files. stdlog is the Julia logging of @info, @warn, @error, etc. Caution: If the original function (p.main) has redirection, arguments defined here might not be effective for it.\n\nnote: Note\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.\n\nWorkflow\n\nGo to the working directory. Establish redirection. (dir, stdout, stderr, stdlog, append).\nValidate compatibility between p and inputs/outputs.\nCheck whether the program has run before. (skip_when_done, p.validate_outputs(outputs))\nCheck command dependencies. (check_dependencies, p.cmd_dependencies)\nValidate inputs. (p.validate_inputs(inputs))\nPreparing before running main command. (p.prerequisites(inputs, outputs))\nRun main function and ***the returned value will be assigned to new outputs***. (outputs = p.main(inputs, outputs))\nValidate outputs. (p.validate_outputs(outputs))\nWrap up. (p.wrap_up(inputs, outputs))\nSuccess, touch run id file, and return (success::Bool, outputs::Dict{String}). (touch_run_id_file::Bool)\n\nExample\n\np = JuliaProgram(\n\tid_file = \"id_file\",\n\tinputs = [\"a\", \"b\"],\n\toutputs = [\"out\"],\n\tmain = (inputs, outputs) -> begin\n\t\ta = inputs[\"a\"]\n\t\tb = inputs[\"b\"]\n\t\tprintln(\"inputs are \", a, \" and \", b)\n\t\tprintln(\"You can also use info in outputs: \", outputs[\"out\"])\n\n\t\tprintln(\"The returned value will be assigned to a new outputs\")\n\t\treturn Dict{String,Any}(\"out\" => b^2)\n\tend\n)\n\ninputs = Dict(\n\t\"a\" => `in1`,\n\t\"b\" => 2\n)\n\noutputs = Dict(\n\t\"out\" => \"will_be_replaced\"\n)\n\nsuccess, outputs = run(p, inputs, outputs;\n\ttouch_run_id_file = false\n) # outputs will be refreshed\n\n\n\n\n\n\n\n","category":"function"},{"location":"API/#Common-Methods","page":"API","title":"Common Methods","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"infer_outputs\ncheck_dependency(::Program)","category":"page"},{"location":"API/#Pipelines.infer_outputs","page":"API","title":"Pipelines.infer_outputs","text":"infer_outputs(p::Program, inputs)\ninfer_outputs(p::Program, inputs, outputs)\n\nInfer the default outputs from p::Program and inputs::Dict{String}.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.check_dependency-Tuple{Program}","page":"API","title":"Pipelines.check_dependency","text":"check_dependency(p::Program)\n\nCheck dependencies listed in p.cmd_dependencies.\n\n\n\n\n\n","category":"method"},{"location":"API/#Command-Dependency","page":"API","title":"Command Dependency","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CmdDependency()\ncheck_dependency(::CmdDependency)\ncheck_dependency_dir(path::AbstractString; exit_when_false=true)\ncheck_dependency_file(path::AbstractString; exit_when_false=true)\nexec","category":"page"},{"location":"API/#Pipelines.CmdDependency-Tuple{}","page":"API","title":"Pipelines.CmdDependency","text":"Struct\n\nmutable struct CmdDependency\n\texec::Base.Cmd\n\ttest_args::Base.Cmd\n\tvalidate_success::Bool\n\tvalidate_stdout::Function\n\tvalidate_stderr::Function\n\texit_when_fail::Bool\nend\n\nMethods\n\nCmdDependency(;\n\texec::Base.Cmd=``,\n\ttest_args::Base.Cmd=``,\n\tvalidate_success::Bool=false,\n\tvalidate_stdout::Function=do_nothing,\n\tvalidate_stderr::Function=do_nothing,\n\texit_when_fail::Bool=true\n)\n\nCreate Command Dependency (CmdDependency).\n\nArguments\n\nexec::AbstractCmd: the command to call the dependency.\ntest_args::AbstractCmd: for testing purposes, the command to be appended to exec.\nvalidate_success::Bool: when checking the dependency, whether to validate the exit code == 0.\nvalidate_stdout::Function: a function takes standard out as String and return the validation result as ::Bool.\nvalidate_stderr::Function: a function takes standard error as String and return the validation result as ::Bool.\nexit_when_fail::Bool: if validation fails, whether to throw error and exit.\n\nExample\n\njulia = CmdDependency(\n\texec = Base.julia_cmd(),\n\ttest_args = `--version`,\n\tvalidate_success = true,\n\tvalidate_stdout = x -> occursin(r\"^julia version\", x),\n\tvalidate_stderr = do_nothing,\n\texit_when_fail = true\n)\n\ncheck_dependency(julia)\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.check_dependency-Tuple{CmdDependency}","page":"API","title":"Pipelines.check_dependency","text":"check_dependency(p::CmdDependency) -> Bool\n\nCheck CmdDependency by evaluating:\n\n`$(p.exec) $(p.test_args)`\n\nIf success, return true.\n\nIf fail, return false, or throw DependencyError when p.exit_when_fail set to true.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.check_dependency_dir-Tuple{AbstractString}","page":"API","title":"Pipelines.check_dependency_dir","text":"check_dependency_dir(path::Union{AbstractString,Cmd}; exit_when_false=true) -> Bool\n\nChecke whether a directory exists. Return ::Bool.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.check_dependency_file-Tuple{AbstractString}","page":"API","title":"Pipelines.check_dependency_file","text":"check_dependency_file(path::Union{AbstractString,Cmd}; exit_when_false=true) -> Bool\n\nChecke whether a file exists. Return ::Bool.\n\n\n\n\n\n","category":"method"},{"location":"API/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"to_str(::Cmd)\nto_cmd(::Cmd)\nsplit(::Cmd)\nreplaceext(::String, ::AbstractString)\nremoveext(::String)","category":"page"},{"location":"API/#Pipelines.to_str-Tuple{Cmd}","page":"API","title":"Pipelines.to_str","text":"to_str(x) -> String\nstr(x) -> String\n\nConvert x to String.\n\nx::Cmd: remove backticks (return string(x)[2:end-1]).\nx::Nothing: return \"\".\nx::Vector: join elements with \"_\" as delim.\nx::Any: return string(x).\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.to_cmd-Tuple{Cmd}","page":"API","title":"Pipelines.to_cmd","text":"to_cmd(x) -> Cmd\n\nConvert x to Cmd.\n\nException: when x::Nothing, return nothing::Nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.split-Tuple{Cmd}","page":"API","title":"Base.split","text":"split(c::Cmd) = c.exec :: Vector{String}\n\nReturn splitted arguments of Cmd.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.replaceext-Tuple{String,AbstractString}","page":"API","title":"Pipelines.replaceext","text":"replaceext(path, replacement::AbstractString)\n\nIf the last component of a path contains a dot, leave everything before the dot as usual, and everything after the dot is replaced by replacement. Otherwise, replacement will be appended to path.\n\nIf replacement is empty, the last dot will be removed.\n\n\n\n\n\n","category":"method"},{"location":"API/#Pipelines.removeext-Tuple{String}","page":"API","title":"Pipelines.removeext","text":"removeext(path)\n\nIf the last component of a path contains a dot, leave everything before the dot as usual, and everything including and after the dot is discarded.\n\n\n\n\n\n","category":"method"},{"location":"API/#Redirection","page":"API","title":"Redirection","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"redirect_to_files\nrestore_stdout\nrestore_stderr","category":"page"},{"location":"API/#Pipelines.redirect_to_files","page":"API","title":"Pipelines.redirect_to_files","text":"redirect_to_files(f::Function, file; mode=\"a+\")\nredirect_to_files(f::Function, outfile, errfile; mode=\"a+\")\nredirect_to_files(f::Function, outfile, errfile, logfile; mode=\"a+\")\n\nRedirect outputs of function f to file(s).\n\nxxxfile: File path (AbstractString), nothing or ::IO. nothing means no redirect. Files can be the same.\nmode: same as open(..., mode).\n\nCaution: If xxxfile is an IO, it won't be closed. Please use close(io) or JobSchedulers.close_in_future(io, jobs) manually!\n\nnote: Note\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks or multi-thread mode.\n\n\n\n\n\n","category":"function"},{"location":"API/#Pipelines.restore_stdout","page":"API","title":"Pipelines.restore_stdout","text":"No documentation found.\n\nPipelines.restore_stderr is a Function.\n\n# 1 method for generic function \"restore_stderr\":\n[1] restore_stderr() in Pipelines at /home/runner/work/Pipelines.jl/Pipelines.jl/src/redirection.jl:24\n\n\n\n","category":"function"}]
}
